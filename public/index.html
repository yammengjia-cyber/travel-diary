<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Travel Diary - åœ°çƒæ—…è¡Œæ—¥è®°</title>
    <style>
        /* ========== å…¨å±€æ ·å¼ ========== */
        body { margin:0; overflow:hidden; height:100vh; cursor:grab; position:relative; background:#5a4a6a; }
        body::before { content:''; position:fixed; inset:0; z-index:0; background:url('/background.png') center/cover no-repeat; opacity:.45; animation:bgBreath 12s ease-in-out infinite; }
        /* ç´«è‰²è¦†ç›– + å…‰ç…§æ–¹å‘æ¨¡æ‹Ÿï¼ˆå·¦ä¾§å†·äº®ã€å³ä¾§æš–æš—ï¼‰ */
        body::after { content:''; position:fixed; inset:0; z-index:0; background:linear-gradient(90deg,rgba(200,220,255,0.10) 0%,rgba(120,125,155,0.50) 25%,rgba(135,115,120,0.55) 75%,rgba(40,20,10,0.15) 100%); pointer-events:none; }
        @keyframes bgBreath { 0%,100%{transform:scale(1);opacity:.4} 50%{transform:scale(1.02) translate(.5%,.5%);opacity:.5} }
        body:active { cursor:grabbing; }
        canvas { display:block; position:absolute; inset:0; z-index:1; background:transparent; }

        /* ========== å·¦ä¸Šè§’ UI ========== */
        #ui-container { position:absolute; top:50px; left:50px; z-index:10; }
        #ui-container p { pointer-events:none; }
        #btn-add-record { margin-top:20px; padding:10px 20px; border:none; border-radius:8px; background:#A78BB3; color:#fff; font-size:14px; font-weight:600; cursor:pointer; letter-spacing:1px; box-shadow:0 2px 8px rgba(0,0,0,.15); display:block; }
        #btn-add-record:hover { background:#9575a8; }
        #btn-add-record.mode { background:#7a6b8a; }
        #btn-add-plan { margin-top:8px; padding:10px 20px; border:none; border-radius:8px; background:#A78BB3; color:#fff; font-size:14px; font-weight:600; cursor:pointer; letter-spacing:1px; box-shadow:0 2px 8px rgba(0,0,0,.15); display:block; }
        #btn-add-plan:hover { background:#9575a8; }
        h1 { font-family:'Times New Roman',serif; color:#333; font-size:3rem; font-weight:300; letter-spacing:4px; margin:0; }
        p { font-family:sans-serif; color:#555; font-size:.85rem; letter-spacing:2px; margin-top:15px; text-transform:uppercase; font-weight:600; }
        .gps-hint { font-size:11px; color:#A78BB3; margin-top:4px; }

        /* ========== çº¬åº¦è½´ ========== */
        #lat-axis { position:fixed; right:20px; top:50%; transform:translateY(-50%); z-index:10; pointer-events:none; width:65px; }
        #lat-axis canvas { display:block; }

        /* ========== è¡¨å•å¼¹çª— ========== */
        #form-overlay { display:none; position:fixed; inset:0; background:rgba(0,0,0,.4); z-index:100; justify-content:center; align-items:center; }
        #form-overlay.show { display:flex; }
        #form-box { background:#fff; border-radius:12px; padding:24px; min-width:400px; max-width:480px; box-shadow:0 8px 32px rgba(0,0,0,.2); max-height:92vh; overflow-y:auto; scrollbar-width:none; }
        #form-box::-webkit-scrollbar { display:none; }
        #form-box h3 { margin:0 0 12px; color:#333; }
        #form-box label { display:block; margin-top:10px; color:#555; font-size:14px; }
        #form-box input[type="text"], #form-box textarea { width:100%; padding:10px; margin-top:4px; box-sizing:border-box; border:1px solid #ddd; border-radius:6px; font-size:14px; }
        #form-box textarea { min-height:36px; height:36px; resize:vertical; }
        #form-box input[type="file"] { margin-top:4px; font-size:13px; }
        #form-box .btns { margin-top:16px; display:flex; gap:10px; justify-content:flex-end; }
        #form-box button { padding:10px 20px; border:none; border-radius:6px; cursor:pointer; font-size:14px; font-weight:600; }
        #form-box button.cancel { background:#eee; color:#555; }
        #form-box button.save { background:#A78BB3; color:#fff; }
        #form-box button.save:hover { background:#9575a8; }
        #form-box .coord { font-size:12px; color:#888; margin-top:4px; }
        #image-count { font-size:11px; color:#A78BB3; margin-top:4px; }
        #btn-map-locate { margin-top:10px; padding:8px 16px; border:1px dashed #A78BB3; border-radius:6px; background:rgba(167,139,179,0.06); color:#A78BB3; font-size:13px; cursor:pointer; display:block; width:100%; text-align:center; }
        #btn-map-locate:hover { background:rgba(167,139,179,0.15); }
        /* æ‹æ‘„æ—¥æœŸé€‰æ‹©å™¨ */
        #date-section { margin-top:10px; }
        #date-section label { font-size:13px; color:#555; }
        #photo-date { padding:8px 12px; border:1px solid #ddd; border-radius:6px; font-size:13px; margin-top:4px; width:100%; box-sizing:border-box; color:#555; }
        #photo-date:focus { border-color:#A78BB3; outline:none; }

        /* ========== AI èŠå¤©åŒºåŸŸ ========== */
        #chat-section { margin-top:14px; border:1px solid #e0e4f0; border-radius:10px; overflow:hidden; background:#fafbfd; }
        #chat-section .chat-header { padding:8px 14px; background:linear-gradient(135deg,#7ba0c4,#8a7fb8); color:#fff; font-size:13px; font-weight:600; display:flex; justify-content:space-between; align-items:center; }
        #chat-section .chat-header .chat-status { font-size:11px; font-weight:400; opacity:.8; }
        #chat-messages { height:220px; overflow-y:auto; padding:12px; scrollbar-width:thin; scrollbar-color:#c0c8e0 transparent; }
        #chat-messages::-webkit-scrollbar { width:4px; }
        #chat-messages::-webkit-scrollbar-thumb { background:#c0c8e0; border-radius:2px; }
        .chat-msg { display:flex; margin-bottom:10px; gap:8px; animation:chatFadeIn 0.35s ease-out; }
        @keyframes chatFadeIn { from{opacity:0;transform:translateY(6px) scale(0.98)} to{opacity:1;transform:translateY(0) scale(1)} }
        .chat-msg.ai { justify-content:flex-start; }
        .chat-msg.user { justify-content:flex-end; }
        .chat-bubble { max-width:78%; padding:8px 12px; border-radius:12px; font-size:13px; line-height:1.6; word-break:break-word; white-space:pre-wrap; transition:transform 0.15s ease, box-shadow 0.15s ease; }
        .chat-msg:hover .chat-bubble { transform:translateY(-1px); box-shadow:0 2px 8px rgba(100,90,130,0.12); }
        .chat-msg.ai .chat-bubble { background:linear-gradient(135deg,#e8e4f2,#dde8f4); color:#3a4060; border-bottom-left-radius:4px; }
        .chat-msg.user .chat-bubble { background:linear-gradient(135deg,#8baac8,#9b8bb8); color:#fff; border-bottom-right-radius:4px; }
        .chat-msg .chat-avatar { width:28px; height:28px; border-radius:50%; flex-shrink:0; display:flex; align-items:center; justify-content:center; font-size:14px; }
        .chat-msg.ai .chat-avatar { background:#dde4f0; }
        .chat-msg.user .chat-avatar { background:#b8c8d8; }
        .chat-typing { display:flex; gap:4px; padding:4px 0; }
        .chat-typing span { width:6px; height:6px; border-radius:50%; background:#a090b8; animation:typingDot 1.2s infinite; }
        .chat-bubble.typing-active { position:relative; }
        .chat-bubble .typing-cursor { display:inline-block; width:2px; height:1.1em; background:#6a7a9a; margin-left:2px; vertical-align:text-bottom; animation:typingBlink 0.8s ease-in-out infinite; }
        @keyframes typingBlink { 0%,50%{opacity:1} 51%,100%{opacity:0.3} }
        .chat-typing span:nth-child(2) { animation-delay:0.2s; }
        .chat-typing span:nth-child(3) { animation-delay:0.4s; }
        @keyframes typingDot { 0%,80%,100%{opacity:.3;transform:scale(0.8)} 40%{opacity:1;transform:scale(1.1)} }

        /* èŠå¤©è¾“å…¥åŒº */
        #chat-input-area { padding:10px 12px; border-top:1px solid #ece4f4; display:flex; gap:8px; align-items:center; background:#fff; }
        #chat-text-input { flex:1; padding:8px 12px; border:1px solid #ddd; border-radius:18px; font-size:13px; outline:none; transition:border-color 0.2s; }
        #chat-text-input:focus { border-color:#A78BB3; }
        #btn-voice { width:40px; height:40px; border-radius:50%; border:none; background:linear-gradient(135deg,#7ba0c4,#8a7fb8); color:#fff; font-size:18px; cursor:pointer; display:flex; align-items:center; justify-content:center; transition:all 0.2s; position:relative; }
        #btn-voice:hover { transform:scale(1.05); box-shadow:0 2px 12px rgba(100,120,180,0.3); }
        #btn-voice.recording { background:linear-gradient(135deg,#e07070,#c05050); animation:voicePulse 1.5s ease-in-out infinite; }
        @keyframes voicePulse { 0%,100%{box-shadow:0 0 0 0 rgba(200,80,80,0.4)} 50%{box-shadow:0 0 0 12px rgba(200,80,80,0)} }
        #btn-chat-send { width:36px; height:36px; border-radius:50%; border:none; background:linear-gradient(135deg,#7ba0c4,#8a7fb8); color:#fff; font-size:15px; cursor:pointer; display:flex; align-items:center; justify-content:center; }
        #btn-chat-send:hover { background:#6a90b8; }

        /* ç²’å­çƒå®¹å™¨ */
        #voice-sphere-wrap { display:none; position:relative; margin:10px auto; width:160px; height:160px; }
        #voice-sphere-wrap.show { display:block; }
        #voice-sphere-canvas { width:160px; height:160px; }
        #voice-interim { position:absolute; bottom:-24px; left:50%; transform:translateX(-50%); font-size:11px; color:#a090b8; white-space:nowrap; max-width:280px; overflow:hidden; text-overflow:ellipsis; }
        #btn-stop-voice { display:none; margin:4px auto 0; padding:5px 16px; border:1px solid rgba(200,100,100,0.4); border-radius:14px; background:rgba(200,80,80,0.1); color:#c06060; font-size:11px; cursor:pointer; text-align:center; }
        #btn-stop-voice.show { display:block; }
        #btn-stop-voice:hover { background:rgba(200,80,80,0.2); }

        /* ========== è®°å½•è¯¦æƒ…å¼¹çª—ï¼ˆæ·±ç´«å‘å…‰ä¿¡å°ï¼‰ ========== */
        #detail-overlay { display:none; position:fixed; inset:0; background:rgba(0,0,0,.65); z-index:200; justify-content:center; align-items:center; }
        #detail-overlay.show { display:flex; }

        /* ä¿¡å°å®¹å™¨ï¼ˆåŒ…å«ç²’å­Canvas + ä¿¡å°ä¸»ä½“ + è£…é¥°ä¿¡å° + Qç‰ˆè§’è‰²ï¼‰ */
        .envelope-wrap { position:relative; max-width:520px; width:92%; overflow:visible; }

        /* Qç‰ˆè§’è‰²ï¼šä¿¡å°å·¦ä¾§ï¼Œåº•éƒ¨å¯¹é½ï¼Œç´§å‡‘å¹¶æ’ */
        .envelope-chibi-wrap {
            position:absolute; right:100%; margin-right:6px; bottom:5%; z-index:5;
            display:flex; align-items:flex-end; flex-direction:row;
            pointer-events:none;
        }
        .envelope-chibi-wrap .chibi-item {
            height:300px; flex-shrink:0;
            animation:chibiStand 3s ease-in-out infinite;
        }
        .envelope-chibi-wrap .chibi-item.chibi-ai-img {
            height:300px;
            filter:drop-shadow(0 2px 10px rgba(60,30,90,0.35));
        }
        .envelope-chibi-wrap .chibi-item + .chibi-item {
            margin-left:-25px;
        }
        .envelope-chibi-wrap .chibi-item.chibi-ai-img img {
            height:100%; width:auto; display:block;
        }
        .envelope-chibi-wrap .chibi-item:nth-child(2) { animation-delay:0.15s; }
        .envelope-chibi-wrap .chibi-item:nth-child(3) { animation-delay:0.3s; }
        @keyframes chibiStand { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-4px)} }
        .envelope-chibi-wrap svg { width:100%; height:100%; filter:drop-shadow(0 3px 6px rgba(0,0,0,0.25)); }

        /* å·¦ä¾§è£…é¥°ä¿¡å°ï¼ˆå€’20åº¦ï¼Œæ¥è¿‘ä¸»ä¿¡å°å¤§å°ï¼‰ */
        .envelope-deco {
            position:absolute; left:-80px; top:50%; width:90%; height:80%;
            transform:translateY(-50%) rotate(-20deg);
            z-index:0; pointer-events:none; opacity:0;
            animation: decoFadeIn 0.8s ease-out 0.2s forwards;
        }
        @keyframes decoFadeIn { 0%{opacity:0;transform:translateY(-50%) rotate(-20deg) translateX(-30px)} 100%{opacity:1;transform:translateY(-50%) rotate(-20deg) translateX(0)} }
        .envelope-deco-body {
            width:100%; height:100%; border-radius:8px;
            background:rgba(90,60,130,0.4);
            backdrop-filter:blur(12px); -webkit-backdrop-filter:blur(12px);
            border:1px solid rgba(180,140,255,0.15);
            box-shadow:0 4px 15px rgba(0,0,0,0.25);
            position:relative; overflow:hidden;
        }
        /* è£…é¥°ä¿¡å°ç²’å­Canvas */
        #deco-particles {
            position:absolute; top:-30px; left:-30px;
            width:calc(100% + 60px); height:calc(100% + 60px);
            pointer-events:none; z-index:2;
        }
        /* è£…é¥°ä¿¡å°çš„ç¿»ç›–ï¼ˆå‘ä¸‹æŠ˜å ï¼Œç›–åœ¨ä¿¡å°æ­£é¢ï¼‰ */
        .envelope-deco-flap {
            position:absolute; top:0; left:0; width:100%; height:30%;
            background:rgba(100,65,150,0.5);
            clip-path:polygon(0 0, 100% 0, 50% 100%);
            filter:drop-shadow(0 2px 6px rgba(0,0,0,0.15));
        }
        /* è£…é¥°ä¿¡å°å†…çº¿æ¡ */
        .envelope-deco-body::after {
            content:''; position:absolute; top:25%; left:15%; right:15%; height:1px;
            background:rgba(255,255,255,0.12);
            box-shadow:0 18px 0 rgba(255,255,255,0.09), 0 36px 0 rgba(255,255,255,0.06), 0 54px 0 rgba(255,255,255,0.04);
        }

        /* ç²’å­Canvasï¼Œç»å¯¹å®šä½é“ºæ»¡+å¤–æ‰© */
        #envelope-particles { position:absolute; top:-40px; left:-40px; width:calc(100% + 80px); height:calc(100% + 80px); pointer-events:none; z-index:0; }

        /* ä¿¡å°ä¸»ä½“ï¼šæµ…ç´«åŠé€æ˜æ¯›ç»ç’ƒ */
        .envelope-card {
            position:relative; z-index:1; border-radius:10px; overflow:visible;
            background:rgba(80,50,120,0.55);
            backdrop-filter:blur(28px); -webkit-backdrop-filter:blur(28px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            border:1px solid rgba(200,160,255,0.15);
            animation: envelopeAppear 0.5s ease-out;
            max-height:90vh; overflow-y:auto; scrollbar-width:none; -ms-overflow-style:none;
        }
        .envelope-card::-webkit-scrollbar { display:none; }
        @keyframes envelopeAppear { 0%{transform:scale(0.85) translateY(30px);opacity:0} 100%{transform:scale(1) translateY(0);opacity:1} }

        /* ä¸»ä¿¡å°ä¸éœ€è¦ç¿»ç›–ä¸‰è§’ï¼Œéšè— */
        .envelope-opening { display:none; }
        .envelope-flap-wrap { display:none; }

        /* ä¿¡å°æ­£æ–‡åŒº */
        .envelope-body { padding:24px 36px 24px; position:relative; }

        /* å®ä¸½æ¥ç…§ç‰‡æ•£è½åŒº */
        .polaroid-area { display:flex; flex-wrap:wrap; gap:12px; justify-content:center; margin-bottom:20px; max-height:320px; overflow-y:auto; padding:8px 0; scrollbar-width:none; -ms-overflow-style:none; }
        .polaroid-area::-webkit-scrollbar { display:none; }
        .polaroid {
            background:#fff; padding:6px 6px 24px 6px; border-radius:2px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.4), 0 0 1px rgba(255,255,255,0.1);
            width:140px; flex-shrink:0;
            opacity:0; transform:translateY(40px) scale(0.8);
            transition: opacity 0.4s ease-out, transform 0.4s ease-out;
            position: relative;
        }
        .polaroid.show { opacity:1; /* transform set by JS with rotation */ }
        .polaroid img { width:100%; height:100px; object-fit:cover; display:block; border-radius:1px; }
        .polaroid-label { font-size:9px; color:#888; text-align:center; margin-top:6px; font-family:'Times New Roman',serif; }
        .polaroid-remove {
            position:absolute; top:4px; right:4px; width:20px; height:20px; border:none; border-radius:50%;
            background:rgba(0,0,0,0.6); color:#fff; font-size:14px; line-height:20px; cursor:pointer;
            z-index:3; display:flex; align-items:center; justify-content:center; padding:0;
        }
        .polaroid-remove:hover { background:rgba(230,80,80,0.95); }

        /* ä¿¡å°å†…æ–‡å­—æ ·å¼ */
        .envelope-card .card-desc { font-size:15px; color:rgba(255,245,255,0.95); line-height:1.7; white-space:pre-wrap; text-shadow:0 1px 4px rgba(0,0,0,0.3); }
        .envelope-card .card-weather { font-size:13px; color:rgba(220,200,240,0.85); margin-top:12px; padding:10px 14px; background:rgba(255,255,255,0.08); border-radius:6px; backdrop-filter:blur(4px); }
        .envelope-card .card-meta { font-size:11px; color:rgba(200,180,220,0.7); margin-top:12px; }
        .envelope-card .card-close { position:absolute; top:8px; right:12px; font-size:22px; color:rgba(255,255,255,0.7); cursor:pointer; z-index:3; transition:color 0.2s; }
        .envelope-card .card-close:hover { color:#fff; }
        .envelope-card .card-continue-chat { padding:8px 16px; border:1px solid rgba(150,160,220,0.3); border-radius:6px; background:transparent; color:rgba(180,190,255,0.8); font-size:12px; cursor:pointer; transition:all 0.2s; }
        .envelope-card .card-continue-chat:hover { background:rgba(120,130,200,0.15); border-color:rgba(150,160,220,0.5); color:#bbc4ff; }
        .envelope-card .card-add-photos { padding:8px 16px; border:1px solid rgba(130,200,180,0.35); border-radius:6px; background:transparent; color:rgba(170,230,210,0.9); font-size:12px; cursor:pointer; transition:all 0.2s; }
        .envelope-card .card-add-photos:hover { background:rgba(70,160,130,0.15); border-color:rgba(130,220,190,0.6); color:#d7fff3; }
        .envelope-card .card-delete { padding:8px 16px; border:1px solid rgba(200,150,180,0.3); border-radius:6px; background:transparent; color:rgba(255,180,180,0.7); font-size:12px; cursor:pointer; display:inline-block; transition:all 0.2s; }
        .envelope-card .card-delete:hover { background:rgba(255,100,100,0.1); border-color:rgba(255,150,150,0.5); color:#faa; }

        /* ========== æ¼‚æµ®å…³é”®è¯æ°”æ³¡ ========== */
        .keywords-float {
            position:absolute; right:-300px; top:50%; transform:translateY(-50%);
            width:290px; display:flex; flex-wrap:wrap; gap:6px; align-items:flex-start; align-content:flex-start;
            justify-content:center;
            pointer-events:none; z-index:2;
            border:1px dashed rgba(200,160,255,0.25); border-radius:10px;
            padding:12px 10px; min-height:60px; max-height:62vh; overflow-y:auto;
            scrollbar-width:none; -ms-overflow-style:none;
        }
        .keywords-float::-webkit-scrollbar { width:0; height:0; display:none; background:transparent; }
        .keywords-float:empty { border-color:transparent; }
        .kw-bubble {
            display:inline-block; width:auto; text-align:center; padding:4px 14px; border-radius:8px;
            font-weight:500; letter-spacing:0.3px;
            backdrop-filter:blur(8px); -webkit-backdrop-filter:blur(8px);
            white-space:nowrap; pointer-events:auto; cursor:pointer;
            position:relative; transition:all 0.15s;
            animation:kwFloat var(--kw-dur, 3s) ease-in-out infinite alternate;
            animation-delay:var(--kw-delay, 0s);
        }
        .kw-bubble:hover { transform:scale(1.05); filter:brightness(1.2); }
        .kw-bubble.big { font-size:13px; padding:5px 16px; font-weight:600; }
        .kw-bubble.small { font-size:11px; padding:4px 12px; }
        @keyframes kwFloat {
            0%{transform:translateY(0) scale(1)} 100%{transform:translateY(var(--kw-dy, -4px)) scale(var(--kw-scale, 1.04))}
        }
        .kw-bubble.purple { background:rgba(120,130,200,0.3); color:rgba(210,215,255,0.95); border:1px solid rgba(150,160,240,0.2); }
        .kw-bubble.purple.big { background:rgba(100,160,200,0.3); color:rgba(200,230,255,0.95); border:1px solid rgba(130,180,240,0.25); }
        .kw-bubble.warm { background:rgba(200,130,80,0.3); color:rgba(255,220,200,0.95); border:1px solid rgba(240,160,120,0.2); }
        .kw-bubble.warm.big { background:rgba(200,160,60,0.3); color:rgba(255,240,200,0.95); border:1px solid rgba(230,190,100,0.25); }

        /* æŸ¥çœ‹å®Œæ•´å¯¹è¯æŒ‰é’® */
        .btn-view-chat {
            position:absolute; right:-290px; bottom:20px; z-index:3;
            padding:6px 14px; border:1px solid rgba(200,160,255,0.25); border-radius:16px;
            background:rgba(80,50,120,0.4); backdrop-filter:blur(8px);
            color:rgba(220,200,255,0.8); font-size:11px; cursor:pointer;
            transition:all 0.2s;
        }
        .btn-view-chat:hover { background:rgba(100,60,150,0.5); color:#fff; }

        /* å®Œæ•´èŠå¤©è®°å½•å¼¹çª— */
        .chat-log-modal {
            position:fixed; inset:0; z-index:300; background:rgba(0,0,0,.5);
            display:flex; justify-content:center; align-items:center;
        }
        .chat-log-card {
            background:#fff; border-radius:12px; width:90%; max-width:500px; max-height:80vh;
            display:flex; flex-direction:column; overflow:hidden;
            box-shadow:0 8px 32px rgba(0,0,0,.3);
        }
        .chat-log-header {
            padding:14px 18px; background:linear-gradient(135deg,#A78BB3,#8a6fa0); color:#fff;
            font-size:14px; font-weight:600; display:flex; justify-content:space-between; align-items:center;
        }
        .chat-log-close { font-size:20px; cursor:pointer; opacity:.8; }
        .chat-log-close:hover { opacity:1; }
        .chat-log-body { padding:16px; overflow-y:auto; flex:1; }
        .chat-log-body .cl-msg { display:flex; margin-bottom:10px; gap:8px; }
        .chat-log-body .cl-msg.ai { justify-content:flex-start; }
        .chat-log-body .cl-msg.user { justify-content:flex-end; }
        .chat-log-body .cl-bubble { max-width:80%; padding:8px 12px; border-radius:12px; font-size:13px; line-height:1.6; white-space:pre-wrap; }
        .chat-log-body .cl-msg.ai .cl-bubble { background:#f0e8f8; color:#4a3660; border-bottom-left-radius:4px; }
        .chat-log-body .cl-msg.user .cl-bubble { background:#A78BB3; color:#fff; border-bottom-right-radius:4px; }
        .cl-kw-mark {
            background:linear-gradient(135deg, rgba(250,235,146,0.6), rgba(220,185,255,0.5));
            color:#2c1840; font-weight:700; padding:1px 4px; border-radius:3px;
        }

        /* ========== é€‰ä½æ¨¡å¼æç¤ºæ¡ ========== */
        #pick-hint { display:none; position:fixed; top:0; left:0; right:0; z-index:80; text-align:center; padding:12px 20px; background:rgba(60,40,80,0.85); backdrop-filter:blur(6px); color:#fff; font-size:14px; letter-spacing:1px; font-weight:500; }
        #pick-hint.show { display:block; }
        #pick-hint .hint-cancel { margin-left:16px; padding:4px 14px; border:1px solid rgba(255,255,255,.5); border-radius:4px; background:transparent; color:#fff; font-size:12px; cursor:pointer; }
        #pick-hint .hint-cancel:hover { background:rgba(255,255,255,.15); }

        /* ========== å®šä½ç¡®è®¤å¡ç‰‡ ========== */
        #loc-confirm { display:none; position:fixed; z-index:90; background:#fff; border-radius:10px; padding:18px 22px; min-width:260px; box-shadow:0 8px 32px rgba(0,0,0,.3); }
        #loc-confirm.show { display:block; }
        #loc-confirm .loc-title { font-size:16px; font-weight:700; color:#333; margin-bottom:4px; }
        #loc-confirm .loc-sub { font-size:12px; color:#888; margin-bottom:14px; }
        #loc-confirm .loc-btns { display:flex; gap:10px; justify-content:flex-end; }
        #loc-confirm .loc-btns button { padding:7px 18px; border:none; border-radius:6px; cursor:pointer; font-size:13px; font-weight:600; }
        #loc-confirm .loc-btn-cancel { background:#eee; color:#666; }
        #loc-confirm .loc-btn-cancel:hover { background:#ddd; }
        #loc-confirm .loc-btn-ok { background:#A78BB3; color:#fff; }
        #loc-confirm .loc-btn-ok:hover { background:#9575a8; }
        #city-search-wrap { margin-top:8px; display:flex; gap:8px; }
        #city-search-input {
            flex:1; padding:8px 10px; border:1px solid rgba(167,139,179,0.35); border-radius:6px;
            font-size:13px; color:#555; box-sizing:border-box;
        }
        #city-search-input:focus { outline:none; border-color:#A78BB3; box-shadow:0 0 0 2px rgba(167,139,179,0.15); }
        #btn-city-search {
            padding:8px 12px; border:1px solid rgba(167,139,179,0.35); border-radius:6px;
            background:rgba(167,139,179,0.08); color:#7f6792; font-size:13px; cursor:pointer; white-space:nowrap;
        }
        #btn-city-search:hover { background:rgba(167,139,179,0.18); }
    </style>
</head>
<body>
    <!-- å·¦ä¸Šè§’UIï¼ˆå»æ‰äº†ç‹¬ç«‹çš„é£æ™¯ç…§æŒ‰é’®ï¼‰ -->
    <div id="ui-container">
        <h1>TRAVEL DIARY</h1>
        <p>Purple Borders Â· å›½å®¶è½®å»“</p>
        <button id="btn-add-record">è®°å½•æ—…è¡Œå›å¿†ğŸ“</button>
        <button id="btn-add-plan">æœªæ¥æ—…è¡Œè®¡åˆ’âœˆï¸</button>
    </div>

    <!-- çº¬åº¦è½´ -->
    <div id="lat-axis"><canvas id="lat-canvas" width="65" height="500"></canvas></div>

    <!-- é€‰ä½æ¨¡å¼æç¤ºæ¡ -->
    <div id="pick-hint">
        ğŸŒ æ—‹è½¬åœ°çƒæ‰¾åˆ°ç›®æ ‡ä½ç½®ï¼Œç„¶å <b>å³é”®ç‚¹å‡»</b> é€‰å–å®šä½
        <button class="hint-cancel" id="pick-hint-cancel">å–æ¶ˆé€‰ä½</button>
    </div>

    <!-- å®šä½ç¡®è®¤å¡ç‰‡ -->
    <div id="loc-confirm">
        <div class="loc-title" id="loc-country">--</div>
        <div class="loc-sub" id="loc-coords">--</div>
        <div class="loc-btns">
            <button class="loc-btn-cancel" id="loc-cancel">é‡æ–°é€‰æ‹©</button>
            <button class="loc-btn-ok" id="loc-ok">ç¡®å®šå®šä½</button>
        </div>
    </div>

    <!-- è¡¨å•å¼¹çª—ï¼ˆå« AI èŠå¤©åŒºåŸŸï¼‰ -->
    <div id="form-overlay">
        <div id="form-box">
            <h3>æ·»åŠ æ—…è¡Œè®°å½•</h3>
            <div class="coord" id="coord-display">ç»çº¬åº¦ï¼š--</div>
            <div id="image-section">
                <label>å›¾ç‰‡ï¼ˆå¯é€‰ï¼Œæ”¯æŒå¤šå¼ ï¼Œè‡ªåŠ¨è¯»å–GPSå®šä½ï¼‰</label>
                <input type="file" id="image-input" accept="image/*" multiple style="margin-top:4px;">
                <div id="image-count"></div>
            </div>
            <div class="gps-hint" id="gps-hint"></div>
            <div id="date-section">
                <label>æ‹æ‘„æ—¥æœŸï¼ˆç”¨äºè·å–å½“æ—¶å¤©æ°”ï¼‰</label>
                <input type="date" id="photo-date" />
            </div>
            <button type="button" id="btn-map-locate">ğŸŒ åœ°å›¾å®šä½</button>
            <div id="city-search-wrap">
                <input type="text" id="city-search-input" placeholder="è¾“å…¥åŸå¸‚åï¼Œç›´æ¥å®šä½ï¼ˆå¦‚ï¼šé˜¿å§†æ–¯ç‰¹ä¸¹ï¼‰" />
                <button type="button" id="btn-city-search">æœç´¢å®šä½</button>
            </div>

            <!-- AI èŠå¤©åŒºåŸŸ -->
            <div id="chat-section" style="display:none;">
                <div class="chat-header">
                    <span id="chat-title">âœ¨ AI æ—…è¡ŒåŠ©æ‰‹</span>
                    <span class="chat-status" id="chat-status">ç­‰å¾…å¼€å§‹...</span>
                </div>
                <!-- ç²’å­çƒå½•éŸ³åŠ¨ç”» -->
                <div id="voice-sphere-wrap">
                    <canvas id="voice-sphere-canvas" width="320" height="320"></canvas>
                    <div id="voice-interim"></div>
                </div>
                <button id="btn-stop-voice">ç‚¹å‡»ç»“æŸå½•éŸ³</button>
                <!-- èŠå¤©æ¶ˆæ¯åŒºåŸŸ -->
                <div id="chat-messages"></div>
                <!-- èŠå¤©è¾“å…¥åŒº -->
                <div id="chat-input-area">
                    <button id="btn-voice" title="è¯­éŸ³è¾“å…¥">ğŸ¤</button>
                    <input type="text" id="chat-text-input" placeholder="è¾“å…¥æ–‡å­—..." />
                    <button id="btn-chat-send" title="å‘é€">â¤</button>
                </div>
            </div>

            <!-- æ–‡å­—æè¿°ï¼ˆåœ¨æœ‰AIæ—¶ä½œä¸ºå¤‡ç”¨/è¡¥å……ï¼Œåœ¨æ— AIæ—¶ä½œä¸ºä¸»è¾“å…¥ï¼‰ -->
            <label id="desc-label">æ–‡å­—æè¿°</label>
            <textarea id="desc-input" placeholder="å†™ä¸‹ä½ çš„æ—…è¡Œæ„Ÿå—..."></textarea>

            <div class="btns">
                <button type="button" class="cancel" id="btn-cancel">å–æ¶ˆ</button>
                <button type="button" class="save" id="btn-save">ä¿å­˜</button>
            </div>
        </div>
    </div>

    <!-- è®°å½•è¯¦æƒ…å¼¹çª—ï¼ˆæ¯›ç»ç’ƒä¿¡å° + å®ä¸½æ¥ç…§ç‰‡ + æ¼‚æµ®å…³é”®è¯ï¼‰ -->
    <div id="detail-overlay">
        <div class="envelope-wrap">
            <!-- å·¦ä¾§ Qç‰ˆ è±†è±†çœ¼è§’è‰²ï¼ˆæ—…è¡Œè®°å½•æœ‰ç…§ç‰‡æ—¶æ˜¾ç¤ºï¼Œæœ€å¤š3äººï¼‰ -->
            <div class="envelope-chibi-wrap" id="envelope-chibi-wrap" style="display:none;"></div>
            <!-- å·¦ä¾§è£…é¥°ä¿¡å° -->
            <div class="envelope-deco">
                <canvas id="deco-particles"></canvas>
                <div class="envelope-deco-flap"></div>
                <div class="envelope-deco-body"></div>
            </div>
            <canvas id="envelope-particles"></canvas>
            <div class="envelope-card">
                <span class="card-close" id="detail-close">&times;</span>
                <div class="envelope-flap-wrap"><div class="envelope-flap"></div></div>
                <div class="envelope-opening"></div>
                <div class="envelope-body">
                    <div class="polaroid-area" id="polaroid-area"></div>
                    <div class="card-desc" id="detail-desc"></div>
                    <div class="card-weather" id="detail-weather" style="display:none"></div>
                    <div class="card-meta" id="detail-meta"></div>
                    <div style="display:flex;gap:10px;align-items:center;margin-top:16px;">
                        <button class="card-add-photos" id="detail-add-photos" style="display:none;">ğŸ“· ç»§ç»­ä¸Šä¼ ç…§ç‰‡</button>
                        <button class="card-continue-chat" id="btn-continue-chat" style="display:none;">ğŸ’¬ ç»§ç»­èŠå¤©</button>
                        <button class="card-delete" id="detail-delete">æ’¤å›æ­¤ä¿¡ç®±</button>
                    </div>
                </div>
            </div>
            <!-- å³ä¾§æ¼‚æµ®å…³é”®è¯åŒºåŸŸ -->
            <div class="keywords-float" id="keywords-float"></div>
            <!-- å³ä¸‹è§’æŸ¥çœ‹å®Œæ•´å¯¹è¯æŒ‰é’® -->
            <button class="btn-view-chat" id="btn-view-chat" style="display:none;">ğŸ’¬ æŸ¥çœ‹å¯¹è¯</button>
        </div>
        <!-- å®Œæ•´èŠå¤©è®°å½•å¼¹çª— -->
        <div class="chat-log-modal" id="chat-log-modal" style="display:none;">
            <div class="chat-log-card">
                <div class="chat-log-header">
                    <span>å®Œæ•´å¯¹è¯è®°å½•</span>
                    <span class="chat-log-close" id="chat-log-close">&times;</span>
                </div>
                <div class="chat-log-body" id="chat-log-body"></div>
            </div>
        </div>
    </div>

    <script src="/heic2any.min.js"></script>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { Line2 } from 'three/addons/lines/Line2.js';
        import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
        import exifr from '/exifr.mjs';

        // ==================== å…¨å±€é…ç½® ====================
        const CONFIG = {
            radius: 280,
            // ç²’å­æ€»æ•°ä¸º1.5å€(240000)ï¼Œç¼©å°æ—¶åªæ˜¾ç¤º67%ï¼Œæ”¾å¤§æ—¶å…¨éƒ¨æ˜¾ç¤º
            targetLand: 240000, targetOcean: 70000, totalSamples: 850000,
            particleBaseSize: 2.6,
            mapUrl: 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_specular_2048.jpg',
            fontUrl: 'https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json',
            colors: {
                land: [new THREE.Color(0xffffff), new THREE.Color(0xfff0c0), new THREE.Color(0xe0d0f0)],
                ocean: new THREE.Color(0xd0c8e8),
                borderLine: new THREE.Color(0x6B4D7E),
                marker: new THREE.Color(0xFF6B6B)
            },
            labels: [
                { cn:'äºš æ´²', en:'ASIA', lat:35, lon:100 },
                { cn:'æ¬§ æ´²', en:'EUROPE', lat:48, lon:15 },
                { cn:'é æ´²', en:'AFRICA', lat:5, lon:20 },
                { cn:'åŒ—ç¾æ´²', en:'NORTH AMERICA', lat:40, lon:-100 },
                { cn:'å—ç¾æ´²', en:'SOUTH AMERICA', lat:-15, lon:-60 },
                { cn:'å¤§æ´‹æ´²', en:'OCEANIA', lat:-25, lon:135 }
            ]
        };

        // ==================== å…¨å±€å˜é‡ ====================
        let scene, camera, renderer, earthGroup, loadedFont;
        let isDragging = false, hasDragged = false;
        let previousMousePosition = { x:0, y:0 };
        let targetRotationX = 0.3, targetRotationY = 4.2;
        let raycaster, mouse, clickSphere;
        let GEO_DATA = null;
        let recordsMarkers = [];          // æ—…è¡Œè®°å½•ä¿¡ç®±Spriteåˆ—è¡¨
        let planMarkers = [];              // æ—…è¡Œè®¡åˆ’çº¢è‰²é‚®ç®±Spriteåˆ—è¡¨
        let awaitingLocationClick = false;
        let continentLabels = [], countryLabels = [];
        let borderLineMaterials = [];
        let highlightBorderGroup = null; // é«˜äº®å›½å¢ƒçº¿å®¹å™¨
        let hoveredFeatureIndex = null;  // å½“å‰æ‚¬åœçš„å›½å®¶ feature ç´¢å¼•
        const ZOOM_THRESHOLD = 600;
        let currentMouseLat = null;
        let particleMaterial = null;       // ç²’å­ShaderMaterialï¼ˆæ§åˆ¶äº®åº¦+é¢å¤–ç²’å­å¯è§æ€§ï¼‰
        let currentDetailGroup = null;     // å½“å‰æ‰“å¼€è¯¦æƒ…çš„Sprite
        let currentDetailType = 'record';  // å½“å‰è¯¦æƒ…ç±»å‹ 'record' | 'plan'
        let mailboxTexture = null;         // æ—…è¡Œè®°å½•é‚®ç®±çº¹ç†
        let planMailboxTexture = null;     // æ—…è¡Œè®¡åˆ’çº¢è‰²é‚®ç®±çº¹ç†
        let formMode = 'record';           // è¡¨å•æ¨¡å¼ 'record' | 'plan'

        // å›½å®¶ä¸­æ–‡åæ˜ å°„
        const ZH={China:'ä¸­å›½','United States of America':'ç¾å›½',Russia:'ä¿„ç½—æ–¯',Japan:'æ—¥æœ¬','United Kingdom':'è‹±å›½',France:'æ³•å›½',Germany:'å¾·å›½',Italy:'æ„å¤§åˆ©',Spain:'è¥¿ç­ç‰™',Canada:'åŠ æ‹¿å¤§',India:'å°åº¦',Brazil:'å·´è¥¿',Australia:'æ¾³å¤§åˆ©äºš',Mexico:'å¢¨è¥¿å“¥','South Korea':'éŸ©å›½',Turkey:'åœŸè€³å…¶',Egypt:'åŸƒåŠ',Iran:'ä¼Šæœ—','Saudi Arabia':'æ²™ç‰¹é˜¿æ‹‰ä¼¯',Indonesia:'å°åº¦å°¼è¥¿äºš',Poland:'æ³¢å…°',Ukraine:'ä¹Œå…‹å…°',Thailand:'æ³°å›½',Vietnam:'è¶Šå—','South Africa':'å—é',Argentina:'é˜¿æ ¹å»·',Netherlands:'è·å…°',Sweden:'ç‘å…¸',Norway:'æŒªå¨',Finland:'èŠ¬å…°',Iceland:'å†°å²›',Greece:'å¸Œè…Š',Portugal:'è‘¡è„ç‰™',Romania:'ç½—é©¬å°¼äºš',Czechia:'æ·å…‹',Belgium:'æ¯”åˆ©æ—¶',Switzerland:'ç‘å£«',Austria:'å¥¥åœ°åˆ©',Hungary:'åŒˆç‰™åˆ©',Denmark:'ä¸¹éº¦',Ireland:'çˆ±å°”å…°','New Zealand':'æ–°è¥¿å…°',Israel:'ä»¥è‰²åˆ—',Morocco:'æ‘©æ´›å“¥',Mongolia:'è’™å¤',Belarus:'ç™½ä¿„ç½—æ–¯',Estonia:'çˆ±æ²™å°¼äºš',Latvia:'æ‹‰è„±ç»´äºš',Lithuania:'ç«‹é™¶å®›',Kazakhstan:'å“ˆè¨å…‹æ–¯å¦',Pakistan:'å·´åŸºæ–¯å¦',Bangladesh:'å­ŸåŠ æ‹‰å›½',Philippines:'è²å¾‹å®¾',Malaysia:'é©¬æ¥è¥¿äºš',Colombia:'å“¥ä¼¦æ¯”äºš',Chile:'æ™ºåˆ©',Peru:'ç§˜é²',Venezuela:'å§”å†…ç‘æ‹‰',Nigeria:'å°¼æ—¥åˆ©äºš',Kenya:'è‚¯å°¼äºš',Iraq:'ä¼Šæ‹‰å…‹',Syria:'å™åˆ©äºš',Jordan:'çº¦æ—¦',Lebanon:'é»å·´å«©','United Arab Emirates':'é˜¿è”é…‹',Cuba:'å¤å·´',Algeria:'é˜¿å°”åŠåˆ©äºš',Libya:'åˆ©æ¯”äºš',Sudan:'è‹ä¸¹',Tanzania:'å¦æ¡‘å°¼äºš','Dem. Rep. Congo':'åˆšæœ(é‡‘)',Madagascar:'é©¬è¾¾åŠ æ–¯åŠ ',Myanmar:'ç¼…ç”¸',Nepal:'å°¼æ³Šå°”',Afghanistan:'é˜¿å¯Œæ±—',Greenland:'æ ¼é™µå…°',Angola:'å®‰å“¥æ‹‰',Mozambique:'è«æ¡‘æ¯”å…‹',Zambia:'èµæ¯”äºš',Zimbabwe:'æ´¥å·´å¸ƒéŸ¦',Botswana:'åšèŒ¨ç“¦çº³',Namibia:'çº³ç±³æ¯”äºš',Somalia:'ç´¢é©¬é‡Œ',Ethiopia:'åŸƒå¡ä¿„æ¯”äºš',Ghana:'åŠ çº³',Cameroon:'å–€éº¦éš†',Uzbekistan:'ä¹Œå…¹åˆ«å…‹æ–¯å¦',Turkmenistan:'åœŸåº“æ›¼æ–¯å¦',Bolivia:'ç»åˆ©ç»´äºš',Paraguay:'å·´æ‹‰åœ­',Uruguay:'ä¹Œæ‹‰åœ­',Ecuador:'å„ç“œå¤šå°”','Papua New Guinea':'å·´å¸ƒäºšæ–°å‡ å†…äºš',Cambodia:'æŸ¬åŸ”å¯¨',Laos:'è€æŒ',Cyprus:'å¡æµ¦è·¯æ–¯',Georgia:'æ ¼é²å‰äºš',Armenia:'äºšç¾å°¼äºš',Azerbaijan:'é˜¿å¡æ‹œç–†',Fiji:'æ–æµ',Kuwait:'ç§‘å¨ç‰¹',Qatar:'å¡å¡”å°”',Oman:'é˜¿æ›¼',Yemen:'ä¹Ÿé—¨',Bhutan:'ä¸ä¸¹','Sri Lanka':'æ–¯é‡Œå…°å¡',Taiwan:'å°æ¹¾','North Korea':'æœé²œ',Croatia:'å…‹ç½—åœ°äºš','Bosnia and Herz.':'æ³¢é»‘',Serbia:'å¡å°”ç»´äºš',Bulgaria:'ä¿åŠ åˆ©äºš',Albania:'é˜¿å°”å·´å°¼äºš','North Macedonia':'åŒ—é©¬å…¶é¡¿',Montenegro:'é»‘å±±',Kosovo:'ç§‘ç´¢æ²ƒ',Moldova:'æ‘©å°”å¤šç“¦',Slovakia:'æ–¯æ´›ä¼å…‹',Slovenia:'æ–¯æ´›æ–‡å°¼äºš',Luxembourg:'å¢æ£®å ¡','W. Sahara':'è¥¿æ’’å“ˆæ‹‰',Tunisia:'çªå°¼æ–¯',Mali:'é©¬é‡Œ',Niger:'å°¼æ—¥å°”',Chad:'ä¹å¾—',Congo:'åˆšæœ(å¸ƒ)',Gabon:'åŠ è“¬',Uganda:'ä¹Œå¹²è¾¾',Rwanda:'å¢æ—ºè¾¾',Senegal:'å¡å†…åŠ å°”',Liberia:'åˆ©æ¯”é‡Œäºš','Burkina Faso':'å¸ƒåŸºçº³æ³•ç´¢',Benin:'è´å®',Togo:'å¤šå“¥','S. Sudan':'å—è‹ä¸¹',Mauritania:'æ¯›é‡Œå¡”å°¼äºš',Palestine:'å·´å‹’æ–¯å¦',Haiti:'æµ·åœ°','Dominican Rep.':'å¤šç±³å°¼åŠ ','Costa Rica':'å“¥æ–¯è¾¾é»åŠ ',Panama:'å·´æ‹¿é©¬',Nicaragua:'å°¼åŠ æ‹‰ç“œ',Honduras:'æ´ªéƒ½æ‹‰æ–¯',Guatemala:'å±åœ°é©¬æ‹‰',Belize:'ä¼¯åˆ©å…¹',Jamaica:'ç‰™ä¹°åŠ ','Puerto Rico':'æ³¢å¤šé»å„'};

        // å¤©æ°”ä»£ç æ˜ å°„
        const WEATHER_DESC = {0:'â˜€ï¸ æ™´',1:'ğŸŒ¤ å°‘äº‘',2:'â›… å¤šäº‘',3:'â˜ï¸ é˜´',45:'ğŸŒ« é›¾',48:'ğŸŒ« æµ“é›¾',51:'ğŸŒ¦ å°é›¨',53:'ğŸŒ¦ ä¸­é›¨',55:'ğŸŒ¦ å¤§é›¨',61:'ğŸŒ§ å°é›¨',63:'ğŸŒ§ ä¸­é›¨',65:'ğŸŒ§ å¤§é›¨',71:'ğŸŒ¨ å°é›ª',73:'ğŸŒ¨ ä¸­é›ª',75:'ğŸŒ¨ å¤§é›ª',80:'ğŸŒ¦ é˜µé›¨',81:'ğŸŒ¦ é˜µé›¨',82:'ğŸŒ¦ å¼ºé˜µé›¨',95:'â›ˆ é›·æš´',96:'â›ˆ å†°é›¹',99:'â›ˆ å†°é›¹'};
        function getWeatherDesc(code) { return WEATHER_DESC[code] || ('å¤©æ°”ä»£ç  ' + code); }

        // ==================== åŠ è½½é‚®ç®±çº¹ç†ï¼ˆå»é™¤æ·±è“èƒŒæ™¯ï¼‰ ====================
        function loadMailboxTex() {
            return new Promise(resolve => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    const c = document.createElement('canvas');
                    c.width = img.width; c.height = img.height;
                    const ctx = c.getContext('2d');
                    // æ°´å¹³é•œåƒç¿»è½¬é‚®ç®±å›¾ç‰‡
                    ctx.translate(c.width, 0);
                    ctx.scale(-1, 1);
                    ctx.drawImage(img, 0, 0);
                    ctx.setTransform(1, 0, 0, 1, 0, 0); // é‡ç½®å˜æ¢
                    const data = ctx.getImageData(0, 0, c.width, c.height);
                    const d = data.data;
                    // å»é™¤æ·±è“è‰²èƒŒæ™¯ (çº¦ rgb(26,42,90))
                    for (let i = 0; i < d.length; i += 4) {
                        const r = d[i], g = d[i+1], b = d[i+2];
                        const dr = r - 26, dg = g - 42, db = b - 90;
                        const dist = Math.sqrt(dr*dr + dg*dg + db*db);
                        if (dist < 55) { d[i+3] = 0; }
                        else if (dist < 75) { d[i+3] = Math.round(255 * (dist - 55) / 20); }
                    }
                    ctx.putImageData(data, 0, 0);
                    // å åŠ å†·æš–å…‰ç…§æ–¹å‘ï¼ˆå·¦å†·å³æš–ï¼‰
                    const grad = ctx.createLinearGradient(0, 0, c.width, 0);
                    grad.addColorStop(0, 'rgba(180,210,255,0.06)');
                    grad.addColorStop(1, 'rgba(255,200,150,0.05)');
                    ctx.globalCompositeOperation = 'overlay';
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, c.width, c.height);
                    ctx.globalCompositeOperation = 'source-over';
                    resolve(new THREE.CanvasTexture(c));
                };
                img.onerror = () => resolve(null);
                img.src = '/mailbox.jpg';
            });
        }

        // åŠ è½½çº¢è‰²é‚®ç®±çº¹ç†ï¼ˆæ—…è¡Œè®¡åˆ’ç”¨ï¼ŒPNGå·²å»èƒŒæ™¯ï¼‰
        function loadPlanMailboxTex() {
            return new Promise(resolve => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    const c = document.createElement('canvas');
                    c.width = img.width; c.height = img.height;
                    const ctx = c.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    resolve(new THREE.CanvasTexture(c));
                };
                img.onerror = () => resolve(null);
                img.src = '/mailbox-plan.png';
            });
        }

        // ==================== å¯åŠ¨ ====================
        loadResources();

        async function loadResources() {
            const manager = new THREE.LoadingManager();
            manager.onLoad = () => init();
            try { const r = await fetch('/ne_110m_admin_0_countries.geojson'); GEO_DATA = await r.json(); } catch(e) { console.warn('GeoJSON fail',e); }
            try { mailboxTexture = await loadMailboxTex(); } catch(e) { console.warn('Mailbox texture fail',e); }
            try { planMailboxTexture = await loadPlanMailboxTex(); } catch(e) { console.warn('Plan mailbox texture fail',e); }
            new FontLoader(manager).load(CONFIG.fontUrl, f => { loadedFont = f; });
            const il = new THREE.ImageLoader(manager); il.setCrossOrigin('Anonymous');
            il.load(CONFIG.mapUrl, img => processMapData(img));
        }

        let mapPixelData, mapWidth, mapHeight;
        function processMapData(image) {
            const c = document.createElement('canvas'); c.width=image.width; c.height=image.height;
            const x = c.getContext('2d'); x.drawImage(image,0,0);
            const d = x.getImageData(0,0,c.width,c.height);
            mapPixelData=d.data; mapWidth=c.width; mapHeight=c.height;
        }

        // ==================== åˆå§‹åŒ–åœºæ™¯ ====================
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x7a6a8a, 0.0007);
            camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 1, 3000);
            camera.position.set(0,0,900);
            renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
            renderer.setSize(innerWidth, innerHeight);
            renderer.setPixelRatio(Math.min(devicePixelRatio, 1.5));
            document.body.appendChild(renderer.domElement);

            createEarthSystem();
            createCanvasLabels();
            createCountryLabels();
            if (GEO_DATA) createBordersFromLocalData();

            const sg = new THREE.SphereGeometry(CONFIG.radius+5,64,64);
            clickSphere = new THREE.Mesh(sg, new THREE.MeshBasicMaterial({visible:false}));
            earthGroup.add(clickSphere);
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // ====== ç¯å…‰ï¼šäº®éƒ¨åå†·ã€æš—éƒ¨åæš– ======
            scene.add(new THREE.AmbientLight(0xffe8d0, 0.35)); // æš–è‰²ç¯å¢ƒå…‰ï¼ˆæš—éƒ¨åŸºè°ƒï¼‰
            const keyLight = new THREE.DirectionalLight(0xd0e8ff, 1.0); // å†·è‰²ä¸»å…‰æºï¼ˆäº®éƒ¨åå†·ï¼‰
            keyLight.position.set(-2, 1, 1);
            scene.add(keyLight);
            const fillLight = new THREE.DirectionalLight(0xffe0c0, 0.4); // æš–è‰²è¡¥å…‰ï¼ˆæš—éƒ¨åæš–ï¼‰
            fillLight.position.set(2, -0.5, 0.5);
            scene.add(fillLight);

            // äº‹ä»¶ç»‘å®š
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('contextmenu', onContextMenu); // å³é”®é€‰ä½
            document.addEventListener('wheel', onMouseWheel);
            // è§¦æ‘¸äº‹ä»¶ï¼ˆç§»åŠ¨ç«¯ï¼‰
            document.addEventListener('touchstart', onTouchStart, {passive:false});
            document.addEventListener('touchmove', onTouchMove, {passive:false});
            document.addEventListener('touchend', onTouchEnd);
            addEventListener('resize', onWindowResize);
            document.getElementById('btn-cancel').addEventListener('click', hideForm);
            document.getElementById('form-overlay').addEventListener('wheel', e => { e.stopPropagation(); }, {passive:false});
            document.getElementById('btn-save').addEventListener('click', onSaveRecord);
            document.getElementById('btn-add-record').addEventListener('click', onAddRecordClick);
            document.getElementById('btn-add-plan').addEventListener('click', onAddPlanClick);
            document.getElementById('detail-close').addEventListener('click', closeDetail);
            // ä¸å†ç‚¹å‡»é®ç½©å…³é—­ï¼Œåªèƒ½ç‚¹Xå…³é—­
            // é˜»æ­¢ä¿¡å°å¼¹çª—å†…çš„æ»šè½®äº‹ä»¶ç©¿é€åˆ°åœ°çƒ
            document.getElementById('detail-overlay').addEventListener('wheel', e => { e.stopPropagation(); }, {passive:false});
            document.getElementById('detail-delete').addEventListener('click', deleteCurrentRecord);
            document.getElementById('image-input').addEventListener('change', onImageSelected);
            // AI èŠå¤©ç›¸å…³äº‹ä»¶
            document.getElementById('btn-voice').addEventListener('click', () => {
                if (isRecording) stopAndSendVoice(); else startRecording();
            });
            document.getElementById('btn-stop-voice').addEventListener('click', () => {
                stopAndSendVoice();
            });
            document.getElementById('btn-chat-send').addEventListener('click', () => {
                const text = document.getElementById('chat-text-input').value.trim();
                if (text) sendChatMessage(text);
            });
            document.getElementById('chat-text-input').addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    const text = e.target.value.trim();
                    if (text) sendChatMessage(text);
                }
            });
            // æŸ¥çœ‹å®Œæ•´å¯¹è¯æŒ‰é’®
            document.getElementById('btn-view-chat').addEventListener('click', showChatLog);
            // è¯¦æƒ…é¡µè¿½åŠ ä¸Šä¼ ç…§ç‰‡
            document.getElementById('detail-add-photos').addEventListener('click', onAddPhotosToRecord);
            // ç»§ç»­èŠå¤©æŒ‰é’®
            document.getElementById('btn-continue-chat').addEventListener('click', onContinueChat);
            document.getElementById('chat-log-close').addEventListener('click', () => {
                document.getElementById('chat-log-modal').style.display = 'none';
            });
            // åˆå§‹åŒ–è¯­éŸ³è¯†åˆ«
            initSpeechRecognition();
            // è¡¨å•å†…"åœ°å›¾å®šä½"æŒ‰é’®
            document.getElementById('btn-map-locate').addEventListener('click', enterPickMode);
            document.getElementById('btn-city-search').addEventListener('click', onCitySearch);
            document.getElementById('city-search-input').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    onCitySearch();
                }
            });
            // é€‰ä½æç¤ºå–æ¶ˆæŒ‰é’®
            document.getElementById('pick-hint-cancel').addEventListener('click', cancelLocationMode);
            // å®šä½ç¡®è®¤å¡ç‰‡æŒ‰é’®
            document.getElementById('loc-ok').addEventListener('click', confirmLocation);
            document.getElementById('loc-cancel').addEventListener('click', ()=>{ hideLocConfirm(); /* ç•™åœ¨é€‰ä½æ¨¡å¼ï¼Œå¯ä»¥é‡æ–°é€‰ */ });

            loadRecords();
            loadPlans();
            animate();
        }

        // ==================== åæ ‡è½¬æ¢ ====================
        function latLonToVector3(lat, lon, radius) {
            const phi = (90-lat)*(Math.PI/180), theta = (180-lon+90)*(Math.PI/180);
            return new THREE.Vector3(radius*Math.sin(phi)*Math.cos(theta), radius*Math.cos(phi), radius*Math.sin(phi)*Math.sin(theta));
        }
        function vector3ToLatLon(v) {
            const r=v.length()||CONFIG.radius+5;
            const phi=Math.acos(Math.max(-1,Math.min(1,v.y/r))), theta=Math.atan2(v.z,v.x);
            let lat=90-phi*(180/Math.PI), lon=270-theta*(180/Math.PI);
            if(lon>180) lon-=360; if(lon<-180) lon+=360;
            return {lat,lon};
        }

        // ==================== ç²’å­åœ°çƒï¼ˆ1.5å€ç²’å­ + brightness + showExtraï¼‰ ====================
        function createEarthSystem() {
            earthGroup = new THREE.Group();
            scene.add(earthGroup);
            const geometry = new THREE.BufferGeometry();
            const positions=[], colors=[], sizes=[], rands=[];
            let landCount=0;
            for(let i=0;i<CONFIG.totalSamples;i++){
                const phi=Math.acos(-1+(2*i)/CONFIG.totalSamples);
                const theta=Math.sqrt(CONFIG.totalSamples*Math.PI)*phi;
                const v=1-(phi/Math.PI), u=(theta/(2*Math.PI))%1;
                let nu=(1-u+.25)%1; if(nu<0) nu+=1;
                const xP=Math.floor(nu*mapWidth), yP=Math.floor((1-v)*mapHeight);
                const idx=(yP*mapWidth+xP)*4;
                if(mapPixelData[idx]>=50) continue;
                if(landCount>=CONFIG.targetLand) continue;
                landCount++;
                let r=CONFIG.radius+Math.random()*5;
                positions.push(r*Math.sin(phi)*Math.cos(theta), r*Math.cos(phi), r*Math.sin(phi)*Math.sin(theta));
                const rnd=Math.random();
                let c=rnd>.5?CONFIG.colors.land[0]:rnd>.2?CONFIG.colors.land[1]:CONFIG.colors.land[2];
                colors.push(c.r,c.g,c.b);
                sizes.push(CONFIG.particleBaseSize*(0.6+Math.random()*1.4));
                rands.push(Math.random()); // éšæœºå€¼ï¼Œç”¨äºå†³å®šæ˜¯å¦ä¸º"é¢å¤–"ç²’å­
            }
            for(let la=-84;la<=84&&positions.length/3-landCount<CONFIG.targetOcean;la+=2.5){
                for(let lo=-177;lo<=177&&positions.length/3-landCount<CONFIG.targetOcean;lo+=3){
                    const phi=(90-la)*(Math.PI/180), theta=(180-lo+90)*(Math.PI/180);
                    const v=1-(phi/Math.PI), u=(theta/(2*Math.PI))%1;
                    let nu=(1-u+.25)%1; if(nu<0)nu+=1;
                    const xP=Math.floor(nu*mapWidth), yP=Math.floor((1-v)*mapHeight);
                    if(mapPixelData[(yP*mapWidth+xP)*4]<50) continue;
                    const r=CONFIG.radius+Math.random();
                    positions.push(r*Math.sin(phi)*Math.cos(theta), r*Math.cos(phi), r*Math.sin(phi)*Math.sin(theta));
                    colors.push(CONFIG.colors.ocean.r, CONFIG.colors.ocean.g, CONFIG.colors.ocean.b);
                    sizes.push(CONFIG.particleBaseSize*1.0);
                    rands.push(-1.0); // è´Ÿå€¼æ ‡è®°æµ·æ´‹ç²’å­
                }
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions,3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors,3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes,1));
            geometry.setAttribute('rand', new THREE.Float32BufferAttribute(rands,1));

            const material = new THREE.ShaderMaterial({
                uniforms:{
                    pointTexture:{value:createHotGlowTexture()},
                    brightness:{value:1.0},
                    showExtra:{value:0.0}  // 0=åªæ˜¾ç¤º67%ç²’å­, 1=å…¨éƒ¨æ˜¾ç¤º
                },
                vertexShader:`
                    attribute float size; attribute vec3 color; attribute float rand;
                    varying vec3 vColor; varying float vDotNV; varying float vRand;
                    void main(){
                        vColor=color; vRand=rand;
                        vec4 mv=modelViewMatrix*vec4(position,1.0);
                        gl_PointSize=size*(800.0/-mv.z);
                        gl_Position=projectionMatrix*mv;
                        vec3 vd=normalize(-mv.xyz);
                        vec3 tn=normalize(normalMatrix*normalize(position));
                        vDotNV=dot(tn,vd);
                    }`,
                fragmentShader:`
                    uniform sampler2D pointTexture; uniform float brightness; uniform float showExtra;
                    varying vec3 vColor; varying float vDotNV; varying float vRand;
                    void main(){
                        float extraAlpha = 1.0;
                        if(vRand < 0.0) {
                            // æµ·æ´‹ç²’å­ï¼šç¼©å°æ—¶å¯è§ï¼Œæ”¾å¤§æ—¶éšè—
                            extraAlpha = 1.0 - smoothstep(0.0, 1.0, showExtra);
                        } else if(vRand > 0.67) {
                            // é¢å¤–é™†åœ°ç²’å­ï¼šæ”¾å¤§æ—¶æ‰æ˜¾ç¤º
                            extraAlpha = smoothstep(0.0, 1.0, showExtra);
                        }
                        float d=mix(0.4,1.4,smoothstep(-0.2,0.7,vDotNV));
                        // æµ·æ´‹ç²’å­ï¼šè¾¹ç¼˜æ›´äº®ï¼ŒåŠ å¼ºçƒä½“ä½“ç§¯æ„Ÿï¼ˆè²æ¶…å°”è¾¹ç¼˜å…‰ï¼‰
                        float rim = 1.0 - smoothstep(0.0, 0.8, vDotNV); // è¾¹ç¼˜=1, ä¸­å¿ƒ=0
                        float oceanD = mix(1.2, 2.5, rim); // ä¸­å¿ƒ1.2ï¼Œè¾¹ç¼˜2.5ï¼Œå¢å¼ºä½“ç§¯æ„Ÿ
                        float finalD = vRand < 0.0 ? oceanD : d;
                        vec4 t=texture2D(pointTexture,gl_PointCoord);
                        if(t.a<0.1) discard;
                        gl_FragColor=vec4(vColor*finalD*2.0*brightness,1.0)*t;
                        gl_FragColor.a=t.a*(0.6+0.4*finalD)*extraAlpha;
                        if(gl_FragColor.a < 0.01) discard;
                    }`,
                blending:THREE.AdditiveBlending, depthTest:false, transparent:true
            });
            particleMaterial = material;
            earthGroup.add(new THREE.Points(geometry, material));
            earthGroup.position.y = -CONFIG.radius*0.6;
            earthGroup.rotation.x = targetRotationX;
            earthGroup.rotation.y = targetRotationY;
        }

        // ==================== å›½å¢ƒçº¿ ====================
        function createBordersFromLocalData() {
            const mat = new LineMaterial({color:0x6B4D7E, linewidth:1, worldUnits:true, transparent:true, opacity:1, resolution:new THREE.Vector2(innerWidth,innerHeight)});
            borderLineMaterials = [mat];
            highlightBorderGroup = new THREE.Group();
            earthGroup.add(highlightBorderGroup);
            GEO_DATA.features.forEach(f => {
                let polys = f.geometry.type==='Polygon'?[f.geometry.coordinates]:f.geometry.coordinates;
                polys.forEach(poly => {
                    const ring=poly[0];
                    const pts=ring.map(c=>latLonToVector3(c[1],c[0],CONFIG.radius+2));
                    const curve=new THREE.CatmullRomCurve3(pts,true,'catmullrom',0.5);
                    const sp=curve.getPoints(Math.min(ring.length*2,120));
                    const g=new LineGeometry(); g.setPositions(sp.flatMap(p=>[p.x,p.y,p.z]));
                    earthGroup.add(new Line2(g, mat));
                });
            });
        }
        // è®¾ç½®æ‚¬åœå›½å®¶çš„é«˜äº®ï¼ˆè¾¹ç•Œçº¿ + æ ‡ç­¾å¼ºè°ƒï¼‰
        function setCountryHover(featureIndex) {
            if (featureIndex === hoveredFeatureIndex) return;
            if (!GEO_DATA || !highlightBorderGroup) return;
            const prev = hoveredFeatureIndex;
            hoveredFeatureIndex = featureIndex;
            // å–æ¶ˆä¸Šä¸€ä¸ªæ ‡ç­¾çš„å¼ºè°ƒ
            countryLabels.forEach(sp => {
                if (sp.userData.featureIndex === prev && sp.userData.baseScale) {
                    const s = sp.userData.baseScale;
                    sp.scale.set(s[0], s[1], 1);
                }
            });
            // æ¸…é™¤é«˜äº®è¾¹ç•Œ
            while (highlightBorderGroup.children.length) highlightBorderGroup.remove(highlightBorderGroup.children[0]);
            if (featureIndex == null) return;
            // é«˜äº®è¾¹ç•Œçº¿ï¼šåŸåœ°å›¾è‰² 0x6B4D7Eï¼Œå†…å®å¤–è™šï¼ˆä¸»çº¿å®å¿ƒ+1.5px ç»†è¾‰å…‰ï¼‰
            const f = GEO_DATA.features[featureIndex];
            const baseR = CONFIG.radius + 2.5;
            const lineColor = 0x6B4D7E; // ä¸åœ°å›¾å›½å¢ƒçº¿ä¸€è‡´
            let polys = f.geometry.type==='Polygon'?[f.geometry.coordinates]:f.geometry.coordinates;
            polys.forEach(poly => {
                const ring=poly[0];
                const pts=ring.map(c=>latLonToVector3(c[1],c[0],baseR));
                const curve=new THREE.CatmullRomCurve3(pts,true,'catmullrom',0.5);
                const sp=curve.getPoints(Math.min(ring.length*2,120));
                const g=new LineGeometry(); g.setPositions(sp.flatMap(p=>[p.x,p.y,p.z]));
                // å¤–åœˆè™šï¼š1.5px ç»†è¾‰å…‰ï¼ŒåŠé€æ˜
                const glowMat = new LineMaterial({color:lineColor, linewidth:1.5, worldUnits:true, transparent:true, opacity:0.38, resolution:new THREE.Vector2(innerWidth,innerHeight)});
                highlightBorderGroup.add(new Line2(g.clone(), glowMat));
                // å†…èŠ¯å®ï¼šç•¥ç²—äºé»˜è®¤ï¼Œä¸é€æ˜
                const mainMat = new LineMaterial({color:lineColor, linewidth:1.15, worldUnits:true, transparent:true, opacity:1, resolution:new THREE.Vector2(innerWidth,innerHeight)});
                highlightBorderGroup.add(new Line2(g, mainMat));
            });
            // å¼ºè°ƒå¯¹åº”å›½å®¶æ ‡ç­¾ï¼ˆæ”¾å¤§ 1.2 å€ï¼‰
            countryLabels.forEach(sp => {
                if (sp.userData.featureIndex === featureIndex && sp.userData.baseScale) {
                    const s = sp.userData.baseScale;
                    sp.scale.set(s[0]*1.2, s[1]*1.2, 1);
                }
            });
        }

        // ==================== æ´²åæ ‡ç­¾ï¼ˆä¿®æ­£æœå‘ï¼šæ­£äº¤åŸºè®©æ–‡å­—ä¿æŒæ°´å¹³ï¼‰ ====================
        function createCanvasLabels() {
            CONFIG.labels.forEach(data => {
                const pos = latLonToVector3(data.lat, data.lon, CONFIG.radius+20);
                const c = document.createElement('canvas'); c.width=1024; c.height=512;
                const x = c.getContext('2d');
                x.textAlign='center';
                x.shadowColor='rgba(255,255,255,0.8)'; x.shadowBlur=40;
                x.font="bold 130px 'Microsoft YaHei','Heiti SC',sans-serif";
                x.fillStyle='rgba(255,255,255,0.5)';
                x.fillText(data.cn, 512, 205);
                x.shadowColor='rgba(255,255,255,0.6)'; x.shadowBlur=20;
                x.fillStyle='#ffffff';
                x.fillText(data.cn, 512, 205);
                x.font="bold 50px 'Arial',sans-serif";
                x.fillStyle='rgba(255,255,255,0.95)';
                x.fillText(data.en, 512, 285);

                const tex = new THREE.CanvasTexture(c);
                const mat = new THREE.MeshBasicMaterial({
                    map:tex, transparent:true, depthTest:false, depthWrite:false,
                    side:THREE.DoubleSide
                });
                const planeGeom = new THREE.PlaneGeometry(120, 60);
                const mesh = new THREE.Mesh(planeGeom, mat);
                mesh.position.copy(pos);

                // ç”¨æ­£äº¤åŸºæ„å»ºæ—‹è½¬ï¼šæ³•çº¿æœå¤– + "ä¸Š"æ–¹å‘å¯¹é½çº¬çº¿æ–¹å‘
                const normal = pos.clone().normalize();
                let worldUp = new THREE.Vector3(0, 1, 0);
                // æç‚¹é™„è¿‘ç”¨åˆ«çš„å‚è€ƒå‘é‡
                if (Math.abs(normal.y) > 0.95) worldUp.set(0, 0, 1);
                const right = new THREE.Vector3().crossVectors(worldUp, normal).normalize();
                const up = new THREE.Vector3().crossVectors(normal, right).normalize();
                const rotMat = new THREE.Matrix4().makeBasis(right, up, normal);
                mesh.quaternion.setFromRotationMatrix(rotMat);

                mesh.userData.type = 'continent';
                earthGroup.add(mesh);
                continentLabels.push(mesh);
            });
        }

        // ==================== å›½å®¶åæ ‡ç­¾ ====================
        function estimateCountrySize(f) {
            let t=0; const cs=f.geometry.type==='Polygon'?[f.geometry.coordinates]:f.geometry.coordinates;
            cs.forEach(p=>p.forEach(r=>{t+=r.length;})); return t;
        }
        // éƒ¨åˆ†å›½å®¶å‡ ä½•ä¸­å¿ƒåç§»ï¼Œä½¿ç”¨äººå·¥æ ¡æ­£åæ ‡ï¼ˆä¸»é¢†åœŸï¼‰
        const COUNTRY_LABEL_OVERRIDE = { 'France':[46.5,2.2], 'United States of America':[39.8,-98.5], 'Russia':[55.8,49.2] };
        function createCountryLabels() {
            if(!GEO_DATA) return;
            GEO_DATA.features.forEach((feature, fi) => {
                const name=feature.properties?.NAME||feature.properties?.ADMIN||'';
                if(!name) return;
                const nameZh=ZH[name]||'';
                let lat, lon;
                const ov = COUNTRY_LABEL_OVERRIDE[name];
                if (ov) { lat=ov[0]; lon=ov[1]; } else {
                    const geom=feature.geometry;
                    let coords=geom.type==='Polygon'?[geom.coordinates[0]]:geom.type==='MultiPolygon'?geom.coordinates.map(c=>c[0]):[];
                    if(!coords.length) return;
                    let sLat=0,sLon=0,n=0;
                    coords.forEach(r=>r.forEach(c=>{sLon+=c[0];sLat+=c[1];n++;}));
                    lat=sLat/n; lon=sLon/n;
                }
                const sz=estimateCountrySize(feature);
                let fontSize, spriteScale;
                if(sz>200){fontSize=50;spriteScale=[91,18,1];}
                else if(sz>60){fontSize=36;spriteScale=[72,14,1];}
                else{fontSize=29;spriteScale=[58,12,1];}
                const pos=latLonToVector3(lat,lon,CONFIG.radius+6);
                const c=document.createElement('canvas'); c.width=512; c.height=110;
                const ctx=c.getContext('2d');
                ctx.textAlign='center';
                ctx.shadowColor='transparent'; ctx.shadowBlur=0;
                ctx.strokeStyle='rgba(80,30,30,0.6)'; ctx.lineWidth=3; ctx.lineJoin='round';
                ctx.fillStyle='#FFF5F5';
                const l1=nameZh||name, l2=nameZh?name:'';
                ctx.font=`900 ${fontSize}px 'Microsoft YaHei','Heiti SC',sans-serif`;
                ctx.strokeText(l1,256,l2?42:60); ctx.fillText(l1,256,l2?42:60);
                if(l2){
                    const es=Math.round(fontSize*.55);
                    ctx.font=`800 ${es}px 'Arial',sans-serif`;
                    ctx.strokeText(l2,256,75); ctx.fillText(l2,256,75);
                }
                const tex=new THREE.CanvasTexture(c);
                const mat=new THREE.SpriteMaterial({map:tex,transparent:true,depthTest:false});
                const sp=new THREE.Sprite(mat); sp.position.copy(pos);
                sp.scale.set(...spriteScale); sp.visible=false; sp.userData.type='country'; sp.userData.featureIndex=fi; sp.userData.baseScale=[...spriteScale];
                earthGroup.add(sp); countryLabels.push(sp);
            });
        }

        // ==================== ç²’å­å‘å…‰çº¹ç† ====================
        function createHotGlowTexture() {
            const c=document.createElement('canvas'); c.width=64;c.height=64;
            const x=c.getContext('2d');
            const g=x.createRadialGradient(32,32,0,32,32,32);
            g.addColorStop(0,'rgba(255,255,255,1)');
            g.addColorStop(.2,'rgba(240,235,255,.9)');
            g.addColorStop(.6,'rgba(0,0,0,0)');
            x.fillStyle=g; x.fillRect(0,0,64,64);
            return new THREE.CanvasTexture(c);
        }

        // ==================== é‚®ç®±æ ‡è®°ï¼ˆä½¿ç”¨å®é™…é‚®ç®±å›¾ç‰‡ä½œä¸ºSpriteï¼‰ ====================
        function createMailboxSprite(lat, lon, record) {
            if (!mailboxTexture) return null;
            const mat = new THREE.SpriteMaterial({map:mailboxTexture, transparent:true, depthTest:false});
            const sp = new THREE.Sprite(mat);
            const pos = latLonToVector3(lat, lon, CONFIG.radius + 10);
            sp.position.copy(pos);
            sp.scale.set(8, 12, 1); // çº¦ä¸ºåŸæ¥çš„ä¸€åŠå¤§å°
            sp.userData = { type:'marker', record: record || {} };
            earthGroup.add(sp);
            recordsMarkers.push(sp);
            return sp;
        }

        // ==================== æ—…è¡Œè®¡åˆ’æ ‡è®°ï¼ˆçº¢è‰²é‚®ç®±Spriteï¼‰ ====================
        function createPlanSprite(lat, lon, plan) {
            if (!planMailboxTexture) return null;
            const mat = new THREE.SpriteMaterial({map:planMailboxTexture, transparent:true, depthTest:false});
            const sp = new THREE.Sprite(mat);
            const pos = latLonToVector3(lat, lon, CONFIG.radius + 10);
            sp.position.copy(pos);
            sp.scale.set(10, 14, 1);
            sp.userData = { type:'plan-marker', plan: plan || {} };
            earthGroup.add(sp);
            planMarkers.push(sp);
            return sp;
        }

        // åœ†è§’çŸ©å½¢è¾…åŠ©
        function roundRect(ctx,x,y,w,h,r){ctx.beginPath();ctx.moveTo(x+r,y);ctx.lineTo(x+w-r,y);ctx.quadraticCurveTo(x+w,y,x+w,y+r);ctx.lineTo(x+w,y+h-r);ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);ctx.lineTo(x+r,y+h);ctx.quadraticCurveTo(x,y+h,x,y+h-r);ctx.lineTo(x,y+r);ctx.quadraticCurveTo(x,y,x+r,y);ctx.closePath();}

        // ==================== çº¬åº¦è½´ ====================
        function drawLatAxis() {
            const cv = document.getElementById('lat-canvas');
            // è®©çº¬åº¦è½´ä¸çƒä½“ç¼©æ”¾ä¿æŒåŒè¶‹åŠ¿ï¼šåœ°çƒè¶Šæ”¾å¤§ï¼ˆzè¶Šå°ï¼‰ï¼Œè½´è¶Šé•¿
            const zoomScale = Math.max(0.75, Math.min(1.85, 900 / camera.position.z));
            const h = Math.min(innerHeight - 40, Math.max(260, Math.round(340 * zoomScale)));
            cv.height = h; cv.width = 65;
            const ctx = cv.getContext('2d');
            ctx.clearRect(0, 0, 65, h);
            const minLat = -90, maxLat = 90;
            const margin = 15;
            const barH = h - margin * 2;
            const rectW = 8, rectH = 2, gap = 2.5;
            const count = Math.floor(barH / (rectH + gap));
            const centerX = 22;

            for (let i = 0; i < count; i++) {
                const y = margin + i * (rectH + gap);
                const lat = maxLat - (i / (count - 1)) * (maxLat - minLat);
                const nearMouse = currentMouseLat !== null && Math.abs(lat - currentMouseLat) < 2.5;
                if (nearMouse) {
                    ctx.fillStyle = '#FAEB92';
                    roundRect(ctx, centerX - rectW * 0.7, y - 0.5, rectW * 1.4, rectH + 1, 1.5);
                } else {
                    ctx.fillStyle = 'rgba(250,235,146,0.25)';
                    roundRect(ctx, centerX - rectW / 2, y, rectW, rectH, 1);
                }
                ctx.fill();
            }
            ctx.font = '9px Arial'; ctx.textAlign = 'left';
            for (let lat = -90; lat <= 90; lat += 15) {
                const y = margin + ((maxLat - lat) / (maxLat - minLat)) * barH;
                ctx.fillStyle = 'rgba(250,235,146,0.5)';
                ctx.fillText(lat + 'Â°', centerX + rectW + 4, y + 3);
            }
            if (currentMouseLat !== null) {
                const y = margin + ((maxLat - currentMouseLat) / (maxLat - minLat)) * barH;
                if (y >= margin && y <= margin + barH) {
                    ctx.fillStyle = '#FAEB92';
                    ctx.beginPath();
                    ctx.moveTo(centerX - rectW - 2, y);
                    ctx.lineTo(centerX - rectW - 8, y - 4);
                    ctx.lineTo(centerX - rectW - 8, y + 4);
                    ctx.closePath(); ctx.fill();
                    ctx.font = 'bold 11px Arial'; ctx.textAlign = 'left';
                    ctx.fillText(currentMouseLat.toFixed(1) + 'Â°', centerX + rectW + 4, y - 6);
                }
            }
        }

        // ==================== EXIF GPSï¼ˆéå†å¤šå¼ å›¾ç‰‡ï¼Œæ‰¾åˆ°ç¬¬ä¸€å¼ å«GPSçš„ï¼‰ ====================
        async function onImageSelected(e) {
            const files = e.target.files;
            const hint = document.getElementById('gps-hint');
            const countEl = document.getElementById('image-count');
            if(!files || files.length === 0) { hint.textContent=''; countEl.textContent=''; return; }
            countEl.textContent = `å·²é€‰æ‹© ${files.length} å¼ å›¾ç‰‡`;
            // éå†æ‰€æœ‰æ–‡ä»¶ï¼Œæ‰¾ç¬¬ä¸€å¼ å«GPSçš„ï¼ŒåŒæ—¶è¯»å–æ‹æ‘„æ—¥æœŸ
            let gpsFound = false;
            let dateFound = false;
            for(let i = 0; i < files.length; i++) {
                try {
                    const gps = await exifr.gps(files[i]);
                    if(!gpsFound && gps && gps.latitude != null && gps.longitude != null) {
                        pendingRecord = { lat: gps.latitude, lon: gps.longitude };
                        // å…ˆç”¨æœ¬åœ° GeoJSON å¿«é€Ÿæ˜¾ç¤ºå›½å®¶
                        const geo = reverseGeocode(gps.latitude, gps.longitude);
                        let label = geo.nameZh ? `${geo.nameZh}ï¼ˆ${geo.name}ï¼‰` : (geo.name || '');
                        let coordText = `ç»çº¬åº¦ï¼š${gps.latitude.toFixed(4)}Â°, ${gps.longitude.toFixed(4)}Â°ï¼ˆä»ç¬¬${i+1}å¼ ç…§ç‰‡GPSè¯»å–ï¼‰`;
                        if(label) coordText += ` Â· ${label}`;
                        document.getElementById('coord-display').textContent = coordText;
                        hint.textContent = `âœ“ å·²ä»ç¬¬${i+1}å¼ ç…§ç‰‡ä¸­è¯»å–GPSåæ ‡`; hint.style.color = '#4a9';
                        gpsFound = true;
                        // å¼‚æ­¥è°ƒç”¨åç«¯è·å–è¯¦ç»†åŸå¸‚ä¿¡æ¯
                        fetch(`/api/reverse-geocode?lat=${gps.latitude}&lon=${gps.longitude}`)
                            .then(r => r.json())
                            .then(d => {
                                if(d.success && d.displayName) {
                                    const coordEl = document.getElementById('coord-display');
                                    coordEl.textContent = `ç»çº¬åº¦ï¼š${gps.latitude.toFixed(4)}Â°, ${gps.longitude.toFixed(4)}Â°ï¼ˆä»ç¬¬${i+1}å¼ ç…§ç‰‡GPSè¯»å–ï¼‰ Â· ${d.displayName}`;
                                }
                            }).catch(()=>{});
                    }
                } catch(err) { /* ç»§ç»­ */ }
                // è¯»å– EXIF æ‹æ‘„æ—¥æœŸ
                if(!dateFound) {
                    try {
                        const exifData = await exifr.parse(files[i], ['DateTimeOriginal','CreateDate']);
                        const dt = exifData?.DateTimeOriginal || exifData?.CreateDate;
                        if(dt) {
                            const d = new Date(dt);
                            if(!isNaN(d.getTime())) {
                                const yyyy = d.getFullYear();
                                const mm = String(d.getMonth()+1).padStart(2,'0');
                                const dd = String(d.getDate()).padStart(2,'0');
                                document.getElementById('photo-date').value = `${yyyy}-${mm}-${dd}`;
                                dateFound = true;
                            }
                        }
                    } catch(err) { /* ç»§ç»­ */ }
                }
                if(gpsFound && dateFound) break;
            }
            if(!gpsFound) {
                hint.textContent = 'æ‰€é€‰ç…§ç‰‡å‡æ— GPSä¿¡æ¯ï¼Œè¯·ç‚¹å‡»ä¸‹æ–¹ã€Œåœ°å›¾å®šä½ã€'; hint.style.color = '#c88';
            }

            // å›¾ç‰‡é€‰å¥½åï¼Œå…ˆä¸Šä¼ å›¾ç‰‡ï¼Œå†å¯åŠ¨ AI èŠå¤©
            if(formMode === 'record' && files.length > 0) {
                const fd = new FormData();
                for(let i = 0; i < files.length; i++) fd.append('images', files[i]);
                try {
                    const uploadRes = await fetch('/api/upload', { method:'POST', body:fd });
                    const uploadData = await uploadRes.json();
                    if(uploadData.paths) {
                        uploadedImagePaths = uploadData.paths;
                        // è·å–åœ°ç†ä½ç½®æ ‡ç­¾
                        const locLabel = pendingRecord
                            ? (() => { const g = reverseGeocode(pendingRecord.lat, pendingRecord.lon); return g.nameZh || g.name || ''; })()
                            : '';
                        startAIChat(uploadedImagePaths, locLabel);
                    } else if(uploadData.error) {
                        hint.textContent = 'âš ï¸ ä¸Šä¼ å¤±è´¥ï¼š' + uploadData.error; hint.style.color = '#c66';
                    }
                } catch(e) {
                    console.warn('å›¾ç‰‡ä¸Šä¼ å¤±è´¥', e);
                    hint.textContent = 'âš ï¸ å›¾ç‰‡ä¸Šä¼ å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–æ–‡ä»¶æ ¼å¼'; hint.style.color = '#c66';
                }
            }
        }

        // ==================== åå‘åœ°ç†ç¼–ç ï¼ˆç”¨GeoJSONåˆ¤æ–­ç‚¹åœ¨å“ªä¸ªå›½å®¶ï¼‰ ====================
        // å°„çº¿æ³•åˆ¤æ–­ç‚¹æ˜¯å¦åœ¨å¤šè¾¹å½¢å†…
        function pointInPolygon(lon, lat, ring) {
            let inside = false;
            for(let i=0,j=ring.length-1; i<ring.length; j=i++) {
                const xi=ring[i][0], yi=ring[i][1], xj=ring[j][0], yj=ring[j][1];
                if((yi>lat)!==(yj>lat) && lon<(xj-xi)*(lat-yi)/(yj-yi)+xi) inside=!inside;
            }
            return inside;
        }
        function reverseGeocode(lat, lon) {
            if(!GEO_DATA) return {name:'', nameZh:'', featureIndex:null};
            for(let fi=0; fi<GEO_DATA.features.length; fi++) {
                const f=GEO_DATA.features[fi], geom=f.geometry, name=f.properties?.NAME||f.properties?.ADMIN||'';
                let polys=[];
                if(geom.type==='Polygon') polys=[geom.coordinates];
                else if(geom.type==='MultiPolygon') polys=geom.coordinates;
                for(const poly of polys) {
                    if(pointInPolygon(lon, lat, poly[0])) {
                        return {name, nameZh: ZH[name]||'', featureIndex:fi};
                    }
                }
            }
            return {name:'Ocean / æµ·æ´‹', nameZh:'æµ·æ´‹', featureIndex:null};
        }

        // åŸå¸‚æœç´¢å®šä½ï¼šé€šè¿‡åç«¯åœ°ç†ç¼–ç å¹¶å¼•å¯¼åœ°çƒè½¬åˆ°ç›®æ ‡ä½ç½®
        function focusGlobeToLocation(lat, lon) {
            const p = latLonToVector3(lat, lon, CONFIG.radius);
            const rotY = Math.atan2(-p.x, p.z);
            const zPrime = Math.sqrt(p.x * p.x + p.z * p.z);
            const rotX = Math.atan2(p.y, zPrime);
            targetRotationY = rotY;
            targetRotationX = rotX;
        }

        async function onCitySearch() {
            const input = document.getElementById('city-search-input');
            const hint = document.getElementById('gps-hint');
            const query = input.value.trim();
            if (!query) {
                hint.textContent = 'è¯·è¾“å…¥åŸå¸‚ååå†æœç´¢';
                hint.style.color = '#c88';
                return;
            }
            hint.textContent = 'æ­£åœ¨æœç´¢åŸå¸‚ä½ç½®...';
            hint.style.color = '#888';
            try {
                const r = await fetch('/api/geocode?query=' + encodeURIComponent(query));
                const d = await r.json();
                if (!d.success || !d.location) {
                    hint.textContent = 'æœªæ‰¾åˆ°è¯¥åŸå¸‚ï¼Œè¯·æ¢ä¸ªåå­—è¯•è¯•';
                    hint.style.color = '#c88';
                    return;
                }
                const { latitude, longitude, name, country } = d.location;
                pendingRecord = { lat: latitude, lon: longitude };
                const label = `${name}${country ? 'ï¼ˆ' + country + 'ï¼‰' : ''}`;
                document.getElementById('coord-display').textContent = `ç»çº¬åº¦ï¼š${latitude.toFixed(4)}Â°, ${longitude.toFixed(4)}Â° Â· ${label}`;
                hint.textContent = `âœ“ å·²æœç´¢å®šä½åˆ°ï¼š${label}`;
                hint.style.color = '#4a9';
                focusGlobeToLocation(latitude, longitude);
                // è®¡åˆ’æ¨¡å¼ä¸‹è‡ªåŠ¨å¯åŠ¨AIè§„åˆ’å¯¹è¯
                if (formMode === 'plan' && !chatSessionId) {
                    startPlanAIChat(label);
                }
            } catch (e) {
                hint.textContent = 'åŸå¸‚æœç´¢å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•';
                hint.style.color = '#c66';
            }
        }

        // ==================== äº¤äº’ ====================
        let pendingRecord = null;
        let pickedLocation = null; // å³é”®é€‰ä¸­çš„ä¸´æ—¶ä½ç½®
        let longPressTimer = null; // é•¿æŒ‰å®šæ—¶å™¨ï¼ˆç§»åŠ¨ç«¯ï¼‰

        // ç‚¹å‡»"æ·»åŠ æ—…è¡Œè®°å½•"æŒ‰é’® â†’ ç›´æ¥æ‰“å¼€è¡¨å•
        function onAddRecordClick() {
            formMode = 'record';
            pendingRecord = null;
            pickedLocation = null;
            showForm(null, null, '');
        }
        function onAddPlanClick() {
            formMode = 'plan';
            pendingRecord = null;
            pickedLocation = null;
            showForm(null, null, '');
        }
        // ç‚¹å‡»è¡¨å•å†…"åœ°å›¾å®šä½"æŒ‰é’® â†’ éšè—è¡¨å•ï¼Œè¿›å…¥é€‰ä½æ¨¡å¼
        function enterPickMode() {
            awaitingLocationClick = true;
            pickedLocation = null;
            // æš‚å­˜è¡¨å•å†…å®¹ï¼Œé€‰ä½åæ¢å¤
            window._savedDesc = document.getElementById('desc-input').value;
            window._savedImageInput = document.getElementById('image-input').files;
            // éšè—è¡¨å•ï¼Œæ˜¾ç¤ºé€‰ä½æç¤º
            document.getElementById('form-overlay').classList.remove('show');
            document.getElementById('pick-hint').classList.add('show');
        }
        // å–æ¶ˆé€‰ä½æ¨¡å¼ â†’ å›åˆ°è¡¨å•
        function cancelLocationMode() {
            awaitingLocationClick=false;
            pickedLocation=null;
            document.getElementById('pick-hint').classList.remove('show');
            hideLocConfirm();
            // æ¢å¤è¡¨å•
            document.getElementById('form-overlay').classList.add('show');
        }
        // æ˜¾ç¤ºå®šä½ç¡®è®¤å¡ç‰‡ï¼ˆå«å›½å®¶+åŸå¸‚ï¼Œé€†åœ°ç†ç¼–ç ï¼‰
        async function showLocConfirm(lat, lon, screenX, screenY) {
            pickedLocation = {lat, lon};
            const geo = reverseGeocode(lat, lon);
            let label = geo.nameZh ? `${geo.nameZh}ï¼ˆ${geo.name}ï¼‰` : (geo.name || '');
            try {
                const r = await fetch(`/api/reverse-geocode?lat=${lat}&lon=${lon}`);
                const d = await r.json();
                if (d.success && d.displayName) label = d.displayName;
            } catch (e) {}
            if (!label) label = 'æœªçŸ¥åŒºåŸŸ';
            document.getElementById('loc-country').textContent = label;
            document.getElementById('loc-coords').textContent = `${lat.toFixed(4)}Â°, ${lon.toFixed(4)}Â°`;
            pickedLocation.label = label;
            const card = document.getElementById('loc-confirm');
            // é™åˆ¶å¡ç‰‡åœ¨å±å¹•èŒƒå›´å†…
            const cw = 280, ch = 110;
            let cx = Math.min(screenX + 12, innerWidth - cw - 16);
            let cy = Math.min(screenY - ch - 12, innerHeight - ch - 16);
            if(cy < 50) cy = screenY + 12;
            if(cx < 16) cx = 16;
            card.style.left = cx + 'px';
            card.style.top = cy + 'px';
            card.classList.add('show');
        }
        function hideLocConfirm() {
            document.getElementById('loc-confirm').classList.remove('show');
            pickedLocation = null;
        }
        // ç¡®è®¤å®šä½ â†’ å›åˆ°è¡¨å•ï¼Œå¡«å…¥ä½ç½®ï¼Œæ¢å¤ä¹‹å‰è¾“å…¥çš„å†…å®¹
        function confirmLocation() {
            if(!pickedLocation) return;
            const {lat, lon, label: locLabel} = pickedLocation;
            pendingRecord = {lat, lon};
            const geo = reverseGeocode(lat, lon);
            const label = locLabel || (geo.nameZh ? `${geo.nameZh}ï¼ˆ${geo.name}ï¼‰` : (geo.name || ''));
            awaitingLocationClick = false;
            document.getElementById('pick-hint').classList.remove('show');
            hideLocConfirm();
            // æ›´æ–°åæ ‡æ˜¾ç¤º
            let coordText = `ç»çº¬åº¦ï¼š${lat.toFixed(4)}Â°, ${lon.toFixed(4)}Â°`;
            if(label) coordText += ` Â· ${label}`;
            document.getElementById('coord-display').textContent = coordText;
            document.getElementById('gps-hint').textContent = 'âœ“ å·²é€šè¿‡åœ°å›¾é€‰å–ä½ç½®';
            document.getElementById('gps-hint').style.color = '#4a9';
            // æ¢å¤ä¹‹å‰çš„æ–‡å­—å†…å®¹ï¼ˆä¸æ¸…ç©ºï¼‰
            if(window._savedDesc) document.getElementById('desc-input').value = window._savedDesc;
            // æ˜¾ç¤ºè¡¨å•
            document.getElementById('form-overlay').classList.add('show');
            // è®¡åˆ’æ¨¡å¼ä¸‹ï¼šé€‰ä½åè‡ªåŠ¨å¯åŠ¨AIæ—…è¡Œè§„åˆ’åŠ©æ‰‹
            if(formMode === 'plan' && !chatSessionId) {
                startPlanAIChat(label || `${lat.toFixed(2)}Â°, ${lon.toFixed(2)}Â°`);
            }
        }

        function onMouseDown(e) {
            if(e.target!==renderer.domElement) return;
            hasDragged = false;
            mouse.x=(e.clientX/innerWidth)*2-1; mouse.y=-(e.clientY/innerHeight)*2+1;
            isDragging=true; previousMousePosition={x:e.clientX, y:e.clientY};
            document.body.style.cursor='grabbing';
        }
        function onMouseMove(e) {
            const mx=(e.clientX/innerWidth)*2-1, my=-(e.clientY/innerHeight)*2+1;
            const rc = new THREE.Raycaster();
            rc.setFromCamera(new THREE.Vector2(mx,my), camera);
            const hits = rc.intersectObject(clickSphere);
            if(hits.length>0 && earthGroup) {
                const lp = hits[0].point.clone().applyMatrix4(earthGroup.matrixWorld.clone().invert());
                const {lat, lon} = vector3ToLatLon(lp);
                currentMouseLat = lat;
                // å›½å®¶æ‚¬åœé«˜äº®ï¼ˆéœ€æ”¾å¤§åˆ°å›½å®¶æ ‡ç­¾å¯è§æ—¶ï¼‰
                if (camera.position.z < ZOOM_THRESHOLD && GEO_DATA) {
                    const geo = reverseGeocode(lat, lon);
                    setCountryHover(geo.featureIndex);
                } else setCountryHover(null);
            } else { currentMouseLat = null; setCountryHover(null); }
            if(!isDragging) return;
            const dx=e.clientX-previousMousePosition.x, dy=e.clientY-previousMousePosition.y;
            if(Math.abs(dx)>2||Math.abs(dy)>2) hasDragged=true;
            targetRotationY+=dx*.003; targetRotationX+=dy*.003;
            previousMousePosition={x:e.clientX,y:e.clientY};
        }
        // å·¦é”®æ¾å¼€ï¼šä»…ç”¨äºç‚¹å‡»ä¿¡ç®±æŸ¥çœ‹è¯¦æƒ…
        function onMouseUp(e) {
            isDragging=false; document.body.style.cursor='grab';
            if(hasDragged || e.target!==renderer.domElement) return;
            // é€‰ä½æ¨¡å¼ä¸‹å·¦é”®ä¸æ“ä½œï¼ˆç”¨å³é”®é€‰ä½ï¼‰
            if(awaitingLocationClick) return;
            mouse.x=(e.clientX/innerWidth)*2-1; mouse.y=-(e.clientY/innerHeight)*2+1;
            raycaster.setFromCamera(mouse, camera);
            // æ£€æµ‹æ—…è¡Œè®°å½•ä¿¡ç®±ç‚¹å‡»
            const markerHits = raycaster.intersectObjects(recordsMarkers);
            if(markerHits.length>0) {
                const rec = markerHits[0].object.userData.record;
                if(rec) { showDetail(rec, markerHits[0].object, 'record'); return; }
            }
            // æ£€æµ‹æ—…è¡Œè®¡åˆ’çº¢è‰²é‚®ç®±ç‚¹å‡»
            const planHits = raycaster.intersectObjects(planMarkers);
            if(planHits.length>0) {
                const plan = planHits[0].object.userData.plan;
                if(plan) { showDetail(plan, planHits[0].object, 'plan'); return; }
            }
        }
        // å³é”®ç‚¹å‡»ï¼šé€‰ä½æ¨¡å¼ä¸‹é€‰æ‹©ä½ç½®
        function onContextMenu(e) {
            if(!awaitingLocationClick) return;
            e.preventDefault();
            const mx=(e.clientX/innerWidth)*2-1, my=-(e.clientY/innerHeight)*2+1;
            raycaster.setFromCamera(new THREE.Vector2(mx,my), camera);
            const hits = raycaster.intersectObject(clickSphere);
            if(hits.length>0) {
                const lp = hits[0].point.clone().applyMatrix4(earthGroup.matrixWorld.clone().invert());
                const {lat,lon} = vector3ToLatLon(lp);
                showLocConfirm(lat, lon, e.clientX, e.clientY);
            }
        }
        // è§¦æ‘¸äº‹ä»¶ï¼ˆç§»åŠ¨ç«¯ï¼‰ï¼šé•¿æŒ‰é€‰ä½
        function onTouchStart(e) {
            if(!awaitingLocationClick) {
                // éé€‰ä½æ¨¡å¼ï¼šå¤„ç†æ‹–æ‹½
                if(e.touches.length!==1) return;
                const t=e.touches[0];
                hasDragged=false; isDragging=true;
                previousMousePosition={x:t.clientX,y:t.clientY};
                return;
            }
            if(e.touches.length!==1) return;
            const t=e.touches[0];
            hasDragged=false; isDragging=true;
            previousMousePosition={x:t.clientX,y:t.clientY};
            // é€‰ä½æ¨¡å¼ä¸‹å¼€å§‹é•¿æŒ‰å®šæ—¶å™¨
            longPressTimer = setTimeout(()=>{
                if(hasDragged) return;
                isDragging=false;
                const mx=(t.clientX/innerWidth)*2-1, my=-(t.clientY/innerHeight)*2+1;
                raycaster.setFromCamera(new THREE.Vector2(mx,my), camera);
                const hits = raycaster.intersectObject(clickSphere);
                if(hits.length>0) {
                    const lp = hits[0].point.clone().applyMatrix4(earthGroup.matrixWorld.clone().invert());
                    const {lat,lon} = vector3ToLatLon(lp);
                    showLocConfirm(lat, lon, t.clientX, t.clientY);
                }
            }, 600);
        }
        function onTouchMove(e) {
            if(e.touches.length!==1) return;
            const t=e.touches[0];
            const dx=t.clientX-previousMousePosition.x, dy=t.clientY-previousMousePosition.y;
            if(Math.abs(dx)>4||Math.abs(dy)>4) { hasDragged=true; if(longPressTimer){clearTimeout(longPressTimer);longPressTimer=null;} }
            if(!isDragging) return;
            targetRotationY+=dx*.003; targetRotationX+=dy*.003;
            previousMousePosition={x:t.clientX,y:t.clientY};
        }
        function onTouchEnd(e) {
            isDragging=false;
            if(longPressTimer){clearTimeout(longPressTimer);longPressTimer=null;}
            // éé€‰ä½æ¨¡å¼ï¼šçŸ­æŒ‰æ£€æµ‹ä¿¡ç®±ç‚¹å‡»
            if(!awaitingLocationClick && !hasDragged && e.changedTouches.length>0) {
                const t=e.changedTouches[0];
                mouse.x=(t.clientX/innerWidth)*2-1; mouse.y=-(t.clientY/innerHeight)*2+1;
                raycaster.setFromCamera(mouse, camera);
                const markerHits = raycaster.intersectObjects(recordsMarkers);
                if(markerHits.length>0) {
                    const rec = markerHits[0].object.userData.record;
                    if(rec) { showDetail(rec, markerHits[0].object, 'record'); return; }
                }
                const planHits = raycaster.intersectObjects(planMarkers);
                if(planHits.length>0) {
                    const plan = planHits[0].object.userData.plan;
                    if(plan) { showDetail(plan, planHits[0].object, 'plan'); return; }
                }
            }
        }
        function onMouseWheel(e) {
            camera.position.z += e.deltaY*0.5;
            camera.position.z = Math.max(350, Math.min(1200, camera.position.z));
        }

        // ==================== ä¿¡å°ç²’å­ç³»ç»Ÿ ====================
        let envelopeParticles = []; // ä¸»ä¿¡å°ç²’å­æ•°ç»„
        let envelopeAnimId = null;  // ä¸»ä¿¡å°åŠ¨ç”»å¸§ID
        let decoParticles = [];     // è£…é¥°ä¿¡å°ç²’å­æ•°ç»„
        let decoAnimId = null;      // è£…é¥°ä¿¡å°åŠ¨ç”»å¸§ID
        const PARTICLE_COLORS = [
            [200,150,255], // æ·¡ç´«
            [255,220,130], // é‡‘è‰²
            [255,255,255], // ç™½è‰²
            [180,120,255], // ç´«
            [255,200,180], // æš–ç™½
        ];
        // åœ¨ä¿¡å°è¾¹ç¼˜éšæœºå–ä¸€ä¸ªç‚¹
        function randomEdgePoint(pad, w, h) {
            const perim = 2*(w+h);
            let t = Math.random() * perim;
            if(t < w) return {x: pad + t, y: pad}; // ä¸Šè¾¹
            t -= w;
            if(t < h) return {x: pad + w, y: pad + t}; // å³è¾¹
            t -= h;
            if(t < w) return {x: pad + w - t, y: pad + h}; // ä¸‹è¾¹
            t -= w;
            return {x: pad, y: pad + h - t}; // å·¦è¾¹
        }

        function initEnvelopeParticles(canvas) {
            const cardEl = canvas.parentElement.querySelector('.envelope-card');
            const rect = cardEl.getBoundingClientRect();
            const pad = 40; // canvas å¤–æ‰©é‡
            canvas.width = rect.width + pad * 2;
            canvas.height = rect.height + pad * 2;
            const ctx = canvas.getContext('2d');
            envelopeParticles = [];
            const cardW = rect.width, cardH = rect.height;

            // è¾¹ç¼˜ç²’å­ï¼šæ²¿ä¿¡å°è¾¹æ¡†åˆ†å¸ƒçš„ç»†å¯†å°ç²’å­ï¼ˆ1000ä¸ªï¼‰
            for(let i = 0; i < 1000; i++) {
                const {x, y} = randomEdgePoint(pad, cardW, cardH);
                const color = PARTICLE_COLORS[Math.floor(Math.random() * PARTICLE_COLORS.length)];
                envelopeParticles.push({
                    x: x + (Math.random()-0.5) * 8,
                    y: y + (Math.random()-0.5) * 8,
                    vx: (Math.random()-0.5) * 0.3,
                    vy: (Math.random()-0.5) * 0.3,
                    size: 0.6 + Math.random() * 1.2, // ç»†å°
                    color,
                    alpha: 0.3 + Math.random() * 0.5,
                    life: 1.5 + Math.random() * 3,
                    maxLife: 0,
                    flickerSpeed: 2 + Math.random() * 4,
                    flickerOffset: Math.random() * Math.PI * 2,
                    decay: 0.005 + Math.random() * 0.004,
                    isEdge: true,
                });
                envelopeParticles[envelopeParticles.length-1].maxLife = envelopeParticles[envelopeParticles.length-1].life;
            }
            // å†…éƒ¨æ•£è½ç²’å­ï¼ˆ30ä¸ªï¼Œåœ¨ç…§ç‰‡åŒºï¼‰
            const cx = canvas.width / 2, photoZoneY = canvas.height * 0.35;
            for(let i = 0; i < 30; i++) {
                const color = PARTICLE_COLORS[Math.floor(Math.random() * PARTICLE_COLORS.length)];
                envelopeParticles.push({
                    x: cx + (Math.random()-0.5) * cardW * 0.6,
                    y: photoZoneY + (Math.random()-0.5) * canvas.height * 0.25,
                    vx: (Math.random()-0.5) * 0.3,
                    vy: (Math.random()-0.5) * 0.3,
                    size: 0.8 + Math.random() * 1.5,
                    color,
                    alpha: 0.2 + Math.random() * 0.4,
                    life: 2 + Math.random() * 3,
                    maxLife: 0,
                    flickerSpeed: 1.5 + Math.random() * 3,
                    flickerOffset: Math.random() * Math.PI * 2,
                    decay: 0.004 + Math.random() * 0.003,
                    isEdge: false,
                });
                envelopeParticles[envelopeParticles.length-1].maxLife = envelopeParticles[envelopeParticles.length-1].life;
            }

            if(envelopeAnimId) cancelAnimationFrame(envelopeAnimId);
            const startTime = performance.now();
            function animateParticles() {
                const elapsed = (performance.now() - startTime) / 1000;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                for(let p of envelopeParticles) {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vx *= 0.99; p.vy *= 0.99;
                    p.life -= p.decay;
                    if(p.life <= 0) {
                        if(p.isEdge) {
                            // è¾¹ç¼˜ç²’å­é‡ç”Ÿåœ¨è¾¹ç¼˜
                            const pt = randomEdgePoint(pad, cardW, cardH);
                            p.x = pt.x + (Math.random()-0.5) * 8;
                            p.y = pt.y + (Math.random()-0.5) * 8;
                            p.vx = (Math.random()-0.5) * 0.3;
                            p.vy = (Math.random()-0.5) * 0.3;
                        } else {
                            // å†…éƒ¨ç²’å­é‡ç”Ÿåœ¨ç…§ç‰‡åŒº
                            p.x = cx + (Math.random()-0.5) * cardW * 0.6;
                            p.y = photoZoneY + (Math.random()-0.5) * canvas.height * 0.2;
                            p.vx = (Math.random()-0.5) * 0.3;
                            p.vy = (Math.random()-0.5) * 0.3;
                        }
                        p.life = 1.5 + Math.random() * 3;
                        p.maxLife = p.life;
                        p.alpha = 0.2 + Math.random() * 0.5;
                        p.color = PARTICLE_COLORS[Math.floor(Math.random() * PARTICLE_COLORS.length)];
                    }
                    const flicker = 0.5 + 0.5 * Math.sin(elapsed * p.flickerSpeed + p.flickerOffset);
                    const lifeAlpha = Math.min(1, p.life / (p.maxLife * 0.3));
                    const a = p.alpha * flicker * lifeAlpha;
                    if(a < 0.01) continue;
                    const [r,g,b] = p.color;
                    // å°ç²’å­ï¼šå®å¿ƒå°åœ†ç‚¹ï¼Œä¸ç”¨å¾„å‘æ¸å˜
                    ctx.fillStyle = `rgba(${r},${g},${b},${a})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                envelopeAnimId = requestAnimationFrame(animateParticles);
            }
            animateParticles();
        }
        // ==================== è£…é¥°ä¿¡å°è¾¹ç¼˜ç²’å­ç³»ç»Ÿ ====================
        function initDecoParticles(canvas) {
            const decoEl = canvas.parentElement;
            const bodyEl = decoEl.querySelector('.envelope-deco-body');
            if(!bodyEl) return;
            const dPad = 30;
            const dW = bodyEl.offsetWidth;
            const dH = bodyEl.offsetHeight;
            canvas.width = dW + dPad * 2;
            canvas.height = dH + dPad * 2;
            const ctx = canvas.getContext('2d');
            decoParticles = [];

            // è£…é¥°ä¿¡å°è¾¹ç¼˜ï¼š600ä¸ªç»†å¯†ç²’å­
            for(let i = 0; i < 600; i++) {
                const {x, y} = randomEdgePoint(dPad, dW, dH);
                const color = PARTICLE_COLORS[Math.floor(Math.random() * PARTICLE_COLORS.length)];
                decoParticles.push({
                    x: x + (Math.random()-0.5) * 6,
                    y: y + (Math.random()-0.5) * 6,
                    vx: (Math.random()-0.5) * 0.25,
                    vy: (Math.random()-0.5) * 0.25,
                    size: 0.5 + Math.random() * 1.0,
                    color,
                    alpha: 0.25 + Math.random() * 0.45,
                    life: 1.5 + Math.random() * 3,
                    maxLife: 0,
                    flickerSpeed: 2 + Math.random() * 4,
                    flickerOffset: Math.random() * Math.PI * 2,
                    decay: 0.005 + Math.random() * 0.004,
                });
                decoParticles[decoParticles.length-1].maxLife = decoParticles[decoParticles.length-1].life;
            }

            if(decoAnimId) cancelAnimationFrame(decoAnimId);
            const startTime = performance.now();
            function animateDeco() {
                const elapsed = (performance.now() - startTime) / 1000;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                for(let p of decoParticles) {
                    p.x += p.vx; p.y += p.vy;
                    p.vx *= 0.99; p.vy *= 0.99;
                    p.life -= p.decay;
                    if(p.life <= 0) {
                        const pt = randomEdgePoint(dPad, dW, dH);
                        p.x = pt.x + (Math.random()-0.5) * 6;
                        p.y = pt.y + (Math.random()-0.5) * 6;
                        p.vx = (Math.random()-0.5) * 0.25;
                        p.vy = (Math.random()-0.5) * 0.25;
                        p.life = 1.5 + Math.random() * 3;
                        p.maxLife = p.life;
                        p.alpha = 0.2 + Math.random() * 0.45;
                        p.color = PARTICLE_COLORS[Math.floor(Math.random() * PARTICLE_COLORS.length)];
                    }
                    const flicker = 0.5 + 0.5 * Math.sin(elapsed * p.flickerSpeed + p.flickerOffset);
                    const lifeAlpha = Math.min(1, p.life / (p.maxLife * 0.3));
                    const a = p.alpha * flicker * lifeAlpha;
                    if(a < 0.01) continue;
                    const [r,g,b] = p.color;
                    ctx.fillStyle = `rgba(${r},${g},${b},${a})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                decoAnimId = requestAnimationFrame(animateDeco);
            }
            animateDeco();
        }

        function stopEnvelopeParticles() {
            if(envelopeAnimId) { cancelAnimationFrame(envelopeAnimId); envelopeAnimId = null; }
            envelopeParticles = [];
            const canvas = document.getElementById('envelope-particles');
            if(canvas) { const ctx = canvas.getContext('2d'); ctx.clearRect(0,0,canvas.width,canvas.height); }
            // åŒæ—¶åœæ­¢è£…é¥°ä¿¡å°ç²’å­
            if(decoAnimId) { cancelAnimationFrame(decoAnimId); decoAnimId = null; }
            decoParticles = [];
            const decoCanvas = document.getElementById('deco-particles');
            if(decoCanvas) { const dCtx = decoCanvas.getContext('2d'); dCtx.clearRect(0,0,decoCanvas.width,decoCanvas.height); }
        }

        // ==================== Qç‰ˆè§’è‰² SVG æ¸²æŸ“å™¨ï¼ˆç²¾è‡´ chibi æ¨¡æ¿ + AI ç‰¹å¾ç€è‰²ï¼‰ ====================
        function renderChibiCharacter(style) {
            const hex = c => /^#[0-9A-Fa-f]{3,8}$/i.test(c||'') ? c : null;
            const topC = hex(style?.topColor) || '#8B7EB8';
            const botC = hex(style?.bottomColor) || '#5A5A7A';
            const hc = hex(style?.hairColor) || '#2a1810';
            // å‘è‰²æ¸å˜ï¼šäº®è‰²å’Œæš—è‰²
            const hcL = adjustColor(hc, 30); // äº®ä¸€ç‚¹çš„å‘è‰²ï¼ˆé«˜å…‰ç”¨ï¼‰
            const hcD = adjustColor(hc, -20); // æš—ä¸€ç‚¹çš„å‘è‰²ï¼ˆé˜´å½±ç”¨ï¼‰
            const hair = (style?.hair || 'long').toLowerCase();
            const skinMap = { light:['#fce4d6','#f0cdb8'], medium:['#f0d0b0','#e4b898'], warm:['#e8c098','#d4a478'] };
            const [skinL, skinD] = skinMap[style?.skin] || skinMap.light;
            const uid = 'ch' + Math.random().toString(36).slice(2,8); // å”¯ä¸€IDå‰ç¼€

            // è¾…åŠ©ï¼šå¾®è°ƒé¢œè‰²æ˜åº¦
            function adjustColor(hex, amt) {
                let c = hex.replace('#','');
                if(c.length===3) c=c[0]+c[0]+c[1]+c[1]+c[2]+c[2];
                let r=parseInt(c.slice(0,2),16), g=parseInt(c.slice(2,4),16), b=parseInt(c.slice(4,6),16);
                r=Math.min(255,Math.max(0,r+amt)); g=Math.min(255,Math.max(0,g+amt)); b=Math.min(255,Math.max(0,b+amt));
                return '#'+[r,g,b].map(v=>v.toString(16).padStart(2,'0')).join('');
            }

            // ---- å‘å‹è·¯å¾„ ----
            let hairBack='', hairFront='', hairSide='';
            if(hair==='short'){
                hairBack=`<ellipse cx="100" cy="58" rx="58" ry="48" fill="url(#${uid}hg)"/>`;
                hairFront=`
                    <path d="M42 75 Q50 38 100 28 Q150 38 158 75 Q148 60 130 52 Q115 42 100 40 Q85 42 70 52 Q52 60 42 75Z" fill="url(#${uid}hg)"/>
                    <path d="M52 65 Q70 48 85 55 L80 60 Q68 52 56 68Z" fill="${hcL}" opacity="0.18"/>`;
            } else if(hair==='medium'){
                hairBack=`<ellipse cx="100" cy="55" rx="60" ry="50" fill="url(#${uid}hg)"/>
                    <path d="M42 80 Q36 110 40 145 L48 145 Q44 110 48 82Z" fill="url(#${uid}hg)"/>
                    <path d="M158 80 Q164 110 160 145 L152 145 Q156 110 152 82Z" fill="url(#${uid}hg)"/>`;
                hairFront=`
                    <path d="M38 78 Q42 32 100 22 Q158 32 162 78 Q150 58 132 50 Q118 38 100 36 Q82 38 68 50 Q50 58 38 78Z" fill="url(#${uid}hg)"/>
                    <path d="M48 68 Q65 45 80 54 L76 58 Q63 48 52 70Z" fill="${hcL}" opacity="0.15"/>
                    <path d="M152 68 Q135 45 120 54 L124 58 Q137 48 148 70Z" fill="${hcL}" opacity="0.15"/>`;
                hairSide=`
                    <path d="M44 85 Q36 105 38 135 L44 134 Q42 106 48 88Z" fill="${hcD}" opacity="0.5"/>
                    <path d="M156 85 Q164 105 162 135 L156 134 Q158 106 152 88Z" fill="${hcD}" opacity="0.5"/>`;
            } else { // long
                hairBack=`<ellipse cx="100" cy="54" rx="62" ry="52" fill="url(#${uid}hg)"/>
                    <path d="M40 78 Q30 130 34 195 L44 194 Q40 130 46 80Z" fill="url(#${uid}hg)"/>
                    <path d="M160 78 Q170 130 166 195 L156 194 Q160 130 154 80Z" fill="url(#${uid}hg)"/>
                    <path d="M44 90 Q32 140 38 200 L46 199 Q38 140 48 92Z" fill="${hcD}" opacity="0.4"/>
                    <path d="M156 90 Q168 140 162 200 L154 199 Q162 140 152 92Z" fill="${hcD}" opacity="0.4"/>`;
                hairFront=`
                    <path d="M36 80 Q40 28 100 18 Q160 28 164 80 Q152 56 134 48 Q118 34 100 32 Q82 34 66 48 Q48 56 36 80Z" fill="url(#${uid}hg)"/>
                    <path d="M46 70 Q64 42 78 52 L74 57 Q62 46 50 72Z" fill="${hcL}" opacity="0.14"/>
                    <path d="M154 70 Q136 42 122 52 L126 57 Q138 46 150 72Z" fill="${hcL}" opacity="0.14"/>`;
                hairSide=`
                    <path d="M42 88 Q32 115 34 155 L42 154 Q38 115 46 90Z" fill="${hcD}" opacity="0.55"/>
                    <path d="M158 88 Q168 115 166 155 L158 154 Q162 115 154 90Z" fill="${hcD}" opacity="0.55"/>`;
            }

            return `<svg viewBox="0 0 200 320" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <radialGradient id="${uid}sk" cx="48%" cy="40%" r="55%"><stop offset="0%" stop-color="${skinL}"/><stop offset="100%" stop-color="${skinD}"/></radialGradient>
                <linearGradient id="${uid}hg" x1="30%" y1="0%" x2="70%" y2="100%"><stop offset="0%" stop-color="${hcL}"/><stop offset="100%" stop-color="${hcD}"/></linearGradient>
                <radialGradient id="${uid}ir" cx="38%" cy="38%" r="55%"><stop offset="0%" stop-color="#6488aa"/><stop offset="100%" stop-color="#3a4a5c"/></radialGradient>
            </defs>
            <!-- åœ°é¢é˜´å½± -->
            <ellipse cx="100" cy="308" rx="42" ry="5" fill="rgba(0,0,0,0.08)"/>

            <!-- å¤´å‘åå±‚ -->
            ${hairBack}

            <!-- èº«ä½“ -->
            <!-- è„–å­ -->
            <rect x="90" y="158" width="20" height="14" rx="6" fill="url(#${uid}sk)"/>
            <!-- ä¸Šè¡£ -->
            <path d="M68 172 Q68 168 74 165 L126 165 Q132 168 132 172 L132 224 Q100 230 68 224Z" fill="${topC}" rx="8"/>
            <!-- è¡£é¢†V -->
            <path d="M84 165 L100 180 L116 165" fill="none" stroke="${adjustColor(topC,-30)}" stroke-width="2.5" stroke-linecap="round"/>
            <!-- ä¸Šè¡£è¤¶çš±æš—ç¤º -->
            <path d="M82 190 Q90 195 88 210" fill="none" stroke="${adjustColor(topC,-20)}" stroke-width="1" opacity="0.3"/>
            <path d="M118 190 Q110 195 112 210" fill="none" stroke="${adjustColor(topC,-20)}" stroke-width="1" opacity="0.3"/>
            <!-- æ‰‹è‡‚+æ‰‹ -->
            <path d="M68 175 Q50 188 44 210" stroke="url(#${uid}sk)" fill="none" stroke-width="12" stroke-linecap="round"/>
            <path d="M132 175 Q150 188 156 210" stroke="url(#${uid}sk)" fill="none" stroke-width="12" stroke-linecap="round"/>
            <circle cx="44" cy="212" r="7" fill="url(#${uid}sk)"/>
            <circle cx="156" cy="212" r="7" fill="url(#${uid}sk)"/>
            <!-- è¢–å£ -->
            <path d="M66 172 Q52 182 48 195" stroke="${topC}" fill="none" stroke-width="10" stroke-linecap="round"/>
            <path d="M134 172 Q148 182 152 195" stroke="${topC}" fill="none" stroke-width="10" stroke-linecap="round"/>
            <!-- ä¸‹è£… -->
            <path d="M70 222 L62 275 Q100 282 138 275 L130 222Z" fill="${botC}"/>
            <!-- è…¿ -->
            <rect x="76" y="272" width="16" height="26" rx="6" fill="url(#${uid}sk)"/>
            <rect x="108" y="272" width="16" height="26" rx="6" fill="url(#${uid}sk)"/>
            <!-- é‹ -->
            <ellipse cx="84" cy="300" rx="14" ry="7" fill="#4a4050"/>
            <ellipse cx="116" cy="300" rx="14" ry="7" fill="#4a4050"/>
            <ellipse cx="84" cy="298" rx="14" ry="4" fill="#5a5060"/>
            <ellipse cx="116" cy="298" rx="14" ry="4" fill="#5a5060"/>

            <!-- å¤´éƒ¨ -->
            <ellipse cx="100" cy="95" rx="62" ry="66" fill="url(#${uid}sk)"/>

            <!-- å¤´å‘ä¾§é¢ -->
            ${hairSide}

            <!-- çœ¼ç› -->
            <!-- å·¦çœ¼ -->
            <ellipse cx="72" cy="92" rx="18" ry="22" fill="white"/>
            <ellipse cx="74" cy="95" rx="14" ry="18" fill="url(#${uid}ir)"/>
            <circle cx="74" cy="96" r="7" fill="#1a1520"/>
            <circle cx="67" cy="86" r="5.5" fill="white" opacity="0.95"/>
            <circle cx="79" cy="90" r="2.8" fill="white" opacity="0.8"/>
            <circle cx="71" cy="102" r="1.5" fill="white" opacity="0.5"/>
            <!-- å³çœ¼ -->
            <ellipse cx="128" cy="92" rx="18" ry="22" fill="white"/>
            <ellipse cx="126" cy="95" rx="14" ry="18" fill="url(#${uid}ir)"/>
            <circle cx="126" cy="96" r="7" fill="#1a1520"/>
            <circle cx="120" cy="86" r="5.5" fill="white" opacity="0.95"/>
            <circle cx="132" cy="90" r="2.8" fill="white" opacity="0.8"/>
            <circle cx="124" cy="102" r="1.5" fill="white" opacity="0.5"/>
            <!-- ä¸Šçœ¼ç‘çº¿ -->
            <path d="M54 78 Q72 70 90 78" fill="none" stroke="#00000018" stroke-width="2.5"/>
            <path d="M110 78 Q128 70 146 78" fill="none" stroke="#00000018" stroke-width="2.5"/>
            <!-- ç«æ¯› -->
            <path d="M54 78 Q50 74 48 70" fill="none" stroke="${hcD}" stroke-width="1.5" stroke-linecap="round" opacity="0.5"/>
            <path d="M146 78 Q150 74 152 70" fill="none" stroke="${hcD}" stroke-width="1.5" stroke-linecap="round" opacity="0.5"/>

            <!-- çœ‰æ¯› -->
            <path d="M56 72 Q68 65 84 70" fill="none" stroke="${hcD}" stroke-width="2.2" opacity="0.35" stroke-linecap="round"/>
            <path d="M116 70 Q132 65 144 72" fill="none" stroke="${hcD}" stroke-width="2.2" opacity="0.35" stroke-linecap="round"/>

            <!-- è…®çº¢ -->
            <ellipse cx="48" cy="108" rx="12" ry="6.5" fill="#FFB0B0" opacity="0.38"/>
            <ellipse cx="152" cy="108" rx="12" ry="6.5" fill="#FFB0B0" opacity="0.38"/>

            <!-- é¼»å­ï¼ˆæå°ï¼‰ -->
            <circle cx="100" cy="106" r="1.5" fill="${skinD}" opacity="0.35"/>

            <!-- å˜´å·´ -->
            <path d="M90 118 Q100 126 110 118" fill="none" stroke="#D06868" stroke-width="2" stroke-linecap="round"/>

            <!-- å¤´å‘å‰å±‚ï¼ˆåˆ˜æµ·ï¼‰-->
            ${hairFront}

            <!-- å¤´å‘é«˜å…‰ -->
            <ellipse cx="78" cy="42" rx="18" ry="5" fill="white" opacity="0.1" transform="rotate(-12,78,42)"/>
            <ellipse cx="118" cy="45" rx="12" ry="3.5" fill="white" opacity="0.07" transform="rotate(8,118,45)"/>
            </svg>`;
        }

        // ==================== è·å–å›¾ç‰‡è·¯å¾„æ•°ç»„ï¼ˆå…¼å®¹æ—§æ•°æ®ï¼‰ ====================
        function getImagePaths(rec) {
            if(rec.imagePaths && Array.isArray(rec.imagePaths) && rec.imagePaths.length > 0) return rec.imagePaths;
            if(rec.imagePath) return [rec.imagePath]; // å…¼å®¹æ—§å•å›¾æ•°æ®
            return [];
        }

        function isCloudinaryUrl(url) {
            return typeof url === 'string' && /res\.cloudinary\.com/i.test(url);
        }

        function toCloudinaryJpgUrl(url) {
            if (!isCloudinaryUrl(url)) return url;
            // Cloudinary åŠ¨æ€æ ¼å¼è½¬æ¢ï¼šçº¿ä¸Š HEIC ç»Ÿä¸€è½¬ JPG å†å±•ç¤º
            const withTransform = url.includes('/upload/')
                ? url.replace('/upload/', '/upload/f_jpg,q_auto/')
                : url;
            return withTransform.replace(/\.(heic|heif)(\?.*)?$/i, '.jpg$2');
        }

        // ==================== ä¿¡å°è¯¦æƒ…ï¼ˆæ·±ç´«ä¿¡å° + å®ä¸½æ¥ + ç²’å­ + å¤©æ°” + æ’¤å›ï¼‰ ====================
        // é¢œè‰²ä¸»é¢˜é…ç½®
        const DETAIL_THEMES = {
            record: {
                cardBg: 'rgba(80,50,120,0.55)',
                border: 'rgba(200,160,255,0.2)',
                decoBg: 'rgba(90,60,130,0.4)',
                decoFlap: 'rgba(100,65,150,0.5)',
                particleColors: [[160,130,220],[130,160,230],[180,150,255],[140,180,240],[200,190,255]],
                deleteText: 'æ’¤å›æ­¤ä¿¡ç®±',
            },
            plan: {
                cardBg: 'rgba(100,60,55,0.5)',
                border: 'rgba(220,160,140,0.2)',
                decoBg: 'rgba(110,65,55,0.35)',
                decoFlap: 'rgba(140,75,65,0.45)',
                particleColors: [[220,180,80],[255,200,100],[200,100,80],[240,160,60],[255,220,130]],
                deleteText: 'å–æ¶ˆæ­¤è®¡åˆ’',
            }
        };

        async function showDetail(rec, markerSprite, type) {
            currentDetailGroup = markerSprite || null;
            currentDetailType = type || 'record';
            const theme = DETAIL_THEMES[currentDetailType];
            const overlay = document.getElementById('detail-overlay');
            const polaroidArea = document.getElementById('polaroid-area');
            const desc = document.getElementById('detail-desc');
            const meta = document.getElementById('detail-meta');
            const weather = document.getElementById('detail-weather');
            const deleteBtn = document.getElementById('detail-delete');
            const addPhotosBtn = document.getElementById('detail-add-photos');
            const card = overlay.querySelector('.envelope-card');
            const decoBody = overlay.querySelector('.envelope-deco-body');
            const decoFlap = overlay.querySelector('.envelope-deco-flap');

            // åº”ç”¨é¢œè‰²ä¸»é¢˜
            card.style.background = theme.cardBg;
            card.style.borderColor = theme.border;
            if(decoBody) decoBody.style.background = theme.decoBg;
            if(decoFlap) decoFlap.style.background = theme.decoFlap;
            deleteBtn.textContent = theme.deleteText;

            // Qç‰ˆè§’è‰²æ˜¾ç¤ºï¼šæ”¯æŒå¤šäººé€æ˜åº•å›¾ç‰‡å¹¶æ’
            const chibiWrap = document.getElementById('envelope-chibi-wrap');
            if (chibiWrap) {
                const chibiPaths = rec.chibiImagePaths || (rec.chibiImagePath ? [rec.chibiImagePath] : []);
                if (currentDetailType === 'record' && chibiPaths.length > 0) {
                    // æ˜¾ç¤º AI ç”Ÿæˆçš„é€æ˜åº•è§’è‰²å›¾ç‰‡ï¼ˆæ”¯æŒå¤šäººï¼‰
                    chibiWrap.style.display = 'flex';
                    chibiWrap.innerHTML = chibiPaths.map((p, i) =>
                        `<div class="chibi-item chibi-ai-img" style="animation-delay:${i * 0.15}s"><img src="${p}" alt="Qç‰ˆè§’è‰²${i+1}" onerror="this.parentElement.style.display='none'"/></div>`
                    ).join('');
                } else {
                    chibiWrap.style.display = 'none';
                    chibiWrap.innerHTML = '';
                }
            }

            // æ¸…ç©ºå®ä¸½æ¥åŒºåŸŸ
            polaroidArea.innerHTML = '';

            if (currentDetailType === 'record') {
                addPhotosBtn.style.display = '';
                addPhotosBtn._rec = rec;
                addPhotosBtn._marker = markerSprite || null;
            } else {
                addPhotosBtn.style.display = 'none';
                addPhotosBtn._rec = null;
                addPhotosBtn._marker = null;
            }

            // å¡«å……æ–‡å­—/å¤©æ°”/å…ƒä¿¡æ¯ï¼ˆä¼˜å…ˆæ˜¾ç¤ºAIæ€»ç»“ï¼Œå…¶æ¬¡ç”¨æˆ·æè¿°ï¼‰
            desc.textContent = cleanAIText(rec.aiSummary || rec.description || 'æ— æ–‡å­—è®°å½•');
            const geo = reverseGeocode(rec.lat, rec.lon);
            const locLabel = geo.nameZh ? `${geo.nameZh}` : (geo.name || '');
            // ä½¿ç”¨æ‹æ‘„æ—¥æœŸï¼ˆå¦‚æœæœ‰ï¼‰ï¼Œå¦åˆ™ç”¨åˆ›å»ºæ—¥æœŸ
            const displayDate = rec.photoDate || (rec.createdAt ? new Date(rec.createdAt).toLocaleDateString('zh-CN') : '');
            meta.textContent = `${locLabel} Â· ${rec.lat?.toFixed(2)}Â°, ${rec.lon?.toFixed(2)}Â° Â· ${displayDate}`;
            if(rec.weather) {
                weather.style.display = 'block';
                const estimated = rec.weather.estimated ? 'ï¼ˆä¼°è®¡ï¼‰' : '';
                weather.textContent = `${getWeatherDesc(rec.weather.weathercode)}  ${rec.weather.temperature}Â°C  é£é€Ÿ ${rec.weather.windspeed} km/h ${estimated}`;
            } else { weather.style.display = 'none'; }

            // è·å–å›¾ç‰‡åˆ—è¡¨ï¼ˆä»…æ—…è¡Œè®°å½•æœ‰å›¾ç‰‡ï¼‰
            const images = currentDetailType === 'record' ? getImagePaths(rec) : [];

            // ç”Ÿæˆå®ä¸½æ¥å¡ç‰‡ï¼ˆHEIC éœ€ heic2any è½¬æ¢åæ˜¾ç¤ºï¼‰
            for (let i = 0; i < images.length; i++) {
                const src = images[i];
                const div = document.createElement('div');
                div.className = 'polaroid';
                const rotate = (Math.random() - 0.5) * 24;
                const tx = (Math.random() - 0.5) * 10;
                div.style.setProperty('--final-rotate', rotate + 'deg');
                div.style.setProperty('--final-tx', tx + 'px');
                if (currentDetailType === 'record') {
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'polaroid-remove';
                    removeBtn.textContent = 'Ã—';
                    removeBtn.title = 'åˆ é™¤è¿™å¼ ç…§ç‰‡';
                    removeBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        await removePhotoFromRecord(rec, markerSprite, src);
                    });
                    div.appendChild(removeBtn);
                }
                const img = document.createElement('img');
                img.alt = `ç…§ç‰‡ ${i+1}`;
                const isHeic = /\.(heic|heif)$/i.test(src);
                if (isHeic) {
                    if (isCloudinaryUrl(src)) {
                        // äº‘ç«¯ HEICï¼šä½¿ç”¨ Cloudinary è½¬ JPG åçš„ URL
                        img.src = toCloudinaryJpgUrl(src);
                    } else {
                        // æœ¬åœ° HEICï¼šé€šè¿‡æœåŠ¡ç«¯è½¬æ¢åæ˜¾ç¤º
                        const filename = src.split('/').pop();
                        img.src = `/api/heic-preview/${encodeURIComponent(filename)}`;
                    }
                    img.onerror = () => { img.style.background='linear-gradient(135deg,#ddd,#bbb)'; img.alt='HEIC ç…§ç‰‡åŠ è½½å¤±è´¥'; img.style.minHeight='120px'; };
                } else {
                    img.src = src;
                    img.onerror = () => {
                        img.removeAttribute('src');
                        img.style.background = 'linear-gradient(135deg,#ddd,#bbb)';
                        img.alt = 'ç…§ç‰‡åŠ è½½å¤±è´¥';
                        img.style.minHeight = '120px';
                    };
                }
                div.appendChild(img);
                const label = document.createElement('div');
                label.className = 'polaroid-label';
                label.textContent = rec.photoDate || (rec.createdAt ? new Date(rec.createdAt).toLocaleDateString('zh-CN') : '');
                div.appendChild(label);
                polaroidArea.appendChild(div);
            }

            // æ¼‚æµ®å…³é”®è¯æ°”æ³¡ï¼ˆæ”¯æŒ {text,type} å¯¹è±¡æ ¼å¼å’Œæ—§ string æ ¼å¼ï¼‰
            const kwFloat = document.getElementById('keywords-float');
            kwFloat.innerHTML = '';
            const keywords = rec.keywords || [];
            const chatLog = rec.chatLog || [];
            if (keywords.length > 0) {
                const bubbleClass = currentDetailType === 'plan' ? 'warm' : 'purple';
                const bigTypes = new Set(['scene','place','feature']);
                keywords.forEach((kw, i) => {
                    const text = typeof kw === 'string' ? kw : kw.text;
                    const type = typeof kw === 'string' ? 'other' : (kw.type || 'other');
                    const isBig = bigTypes.has(type);
                    const span = document.createElement('span');
                    span.className = 'kw-bubble ' + bubbleClass + (isBig ? ' big' : ' small');
                    span.textContent = text;
                    // éšæœºåŠ¨ç”»å‚æ•°
                    const dur = 2.5 + Math.random() * 2;
                    const delay = Math.random() * 2;
                    const dy = -(2 + Math.random() * 3);
                    const scale = 1.01 + Math.random() * 0.03;
                    span.style.setProperty('--kw-dur', dur + 's');
                    span.style.setProperty('--kw-delay', delay + 's');
                    span.style.setProperty('--kw-dy', dy + 'px');
                    span.style.setProperty('--kw-scale', scale);
                    // è½»å¾®æ•£è½
                    span.style.marginLeft = (Math.random() * 8) + 'px';
                    // ç‚¹å‡»å…³é”®è¯ â†’ æ‰“å¼€èŠå¤©è®°å½•å¹¶è·³è½¬åˆ°åŒ…å«æ­¤å…³é”®è¯çš„æ¶ˆæ¯
                    if (chatLog.length > 0) {
                        span.addEventListener('click', () => jumpToChatKeyword(text, chatLog));
                    }
                    kwFloat.appendChild(span);
                });
            }

            // æŸ¥çœ‹å®Œæ•´å¯¹è¯ & ç»§ç»­èŠå¤©æŒ‰é’®
            const chatBtn = document.getElementById('btn-view-chat');
            const continueBtn = document.getElementById('btn-continue-chat');
            if (rec.chatLog && rec.chatLog.length > 0) {
                chatBtn.style.display = '';
                chatBtn._chatLog = rec.chatLog;
                continueBtn.style.display = '';
                continueBtn._rec = rec;
                continueBtn._type = type;
            } else {
                chatBtn.style.display = 'none';
                continueBtn.style.display = 'none';
            }

            // æ˜¾ç¤ºä¿¡å°
            overlay.classList.add('show');

            // é‡æ–°è§¦å‘CSSåŠ¨ç”»
            card.style.animation = 'none'; card.offsetHeight; card.style.animation = '';

            // å¯åŠ¨ç²’å­æ•ˆæœï¼ˆä½¿ç”¨ä¸»é¢˜é¢œè‰²ï¼ŒåŒ…æ‹¬ä¸»ä¿¡å°å’Œè£…é¥°ä¿¡å°ï¼‰
            setTimeout(() => {
                PARTICLE_COLORS.length = 0;
                theme.particleColors.forEach(c => PARTICLE_COLORS.push(c));
                initEnvelopeParticles(document.getElementById('envelope-particles'));
                initDecoParticles(document.getElementById('deco-particles'));
            }, 100);

            // ç…§ç‰‡ä¾æ¬¡é£˜å‡ºåŠ¨ç”»
            const polaroids = polaroidArea.querySelectorAll('.polaroid');
            polaroids.forEach((p, i) => {
                setTimeout(() => {
                    const rotate = p.style.getPropertyValue('--final-rotate');
                    const tx = p.style.getPropertyValue('--final-tx');
                    p.style.transform = `translateY(0) scale(1) rotate(${rotate}) translateX(${tx})`;
                    p.classList.add('show');
                }, 900 + i * 150);
            });
        }

        // æ˜¾ç¤ºå®Œæ•´èŠå¤©è®°å½•
        function showChatLog() {
            const chatBtn = document.getElementById('btn-view-chat');
            const chatLog = chatBtn._chatLog;
            if (!chatLog || chatLog.length === 0) return;
            const body = document.getElementById('chat-log-body');
            body.innerHTML = '';
            chatLog.forEach(msg => {
                const div = document.createElement('div');
                div.className = 'cl-msg ' + (msg.role === 'ai' ? 'ai' : 'user');
                const bubble = document.createElement('div');
                bubble.className = 'cl-bubble';
                bubble.textContent = msg.role === 'ai' ? cleanAIText(msg.text) : msg.text;
                div.appendChild(bubble);
                body.appendChild(div);
            });
            document.getElementById('chat-log-modal').style.display = 'flex';
        }

        // ç‚¹å‡»å…³é”®è¯ â†’ æ‰“å¼€èŠå¤©è®°å½•å¹¶é«˜äº®å…³é”®è¯æ–‡å­—ï¼Œæ»šåŠ¨åˆ°å¯¹åº”æ¶ˆæ¯
        function jumpToChatKeyword(keyword, chatLog) {
            if (!chatLog || chatLog.length === 0) return;
            const body = document.getElementById('chat-log-body');
            body.innerHTML = '';
            let targetEl = null;
            // è½¬ä¹‰æ­£åˆ™ç‰¹æ®Šå­—ç¬¦
            const escaped = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const re = new RegExp(`(${escaped})`, 'gi');
            chatLog.forEach((msg, idx) => {
                const div = document.createElement('div');
                div.className = 'cl-msg ' + (msg.role === 'ai' ? 'ai' : 'user');
                const bubble = document.createElement('div');
                bubble.className = 'cl-bubble';
                const cleanText = msg.role === 'ai' ? cleanAIText(msg.text) : msg.text;
                if (cleanText.includes(keyword)) {
                    // ç”¨ <mark> é«˜äº®å…³é”®è¯ï¼Œå…¶ä½™ä¿æŒåŸæ ·
                    bubble.innerHTML = cleanText.replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(re, '<span class="cl-kw-mark">$1</span>');
                    if (!targetEl) targetEl = div;
                } else {
                    bubble.textContent = cleanText;
                }
                div.appendChild(bubble);
                body.appendChild(div);
            });
            document.getElementById('chat-log-modal').style.display = 'flex';
            if (targetEl) {
                setTimeout(() => targetEl.scrollIntoView({ behavior: 'smooth', block: 'center' }), 100);
            }
        }

        // ç»§ç»­èŠå¤©ï¼šä»è¯¦æƒ…é¡µæ¢å¤å¯¹è¯
        async function onContinueChat() {
            const btn = document.getElementById('btn-continue-chat');
            const rec = btn._rec;
            const type = btn._type || 'record';
            if (!rec || !rec.chatLog || rec.chatLog.length === 0) return;

            btn.textContent = 'æ­£åœ¨æ¢å¤...';
            btn.disabled = true;
            try {
                // æ¢å¤ä¼šè¯
                const r = await fetch('/api/chat/resume', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ chatLog: rec.chatLog, keywords: rec.keywords, type })
                });
                const d = await r.json();
                if (!d.success) { alert('æ¢å¤å¯¹è¯å¤±è´¥ï¼š' + (d.error || '')); return; }

                // å…³é—­è¯¦æƒ…å¼¹çª—
                closeDetail();

                // è®¾ç½®è¡¨å•æ¨¡å¼
                formMode = type;
                pendingRecord = { lat: rec.lat, lon: rec.lon };

                // å…ˆæ˜¾ç¤ºè¡¨å•ï¼ˆshowForm ä¼šæ¸…ç©ºèŠå¤©çŠ¶æ€ï¼‰ï¼Œå†æ¢å¤ä¼šè¯ID
                showForm(rec.lat, rec.lon);
                chatSessionId = d.sessionId;
                isChatActive = true;
                chatKeywords = rec.keywords || [];

                // æ˜¾ç¤ºèŠå¤©åŒºåŸŸå¹¶æ¢å¤å†å²æ¶ˆæ¯
                const chatSection = document.getElementById('chat-section');
                const chatMsgs = document.getElementById('chat-messages');
                chatSection.style.display = '';
                chatMsgs.innerHTML = '';
                document.getElementById('chat-title').textContent = type === 'plan' ? 'ğŸ± æ¼«æ¸¸å–µ Â· ç»§ç»­è§„åˆ’' : 'ğŸ¦Œ æ‹¾å…‰é¹¿ Â· ç»§ç»­å›å¿†';
                document.getElementById('chat-status').textContent = 'å¯¹è¯ä¸­';

                // æ¸²æŸ“å†å²æ¶ˆæ¯ï¼ˆæœ€å 6 æ¡ï¼‰
                const recentLog = rec.chatLog.slice(-6);
                recentLog.forEach(msg => appendChatMsg(msg.role === 'ai' ? 'ai' : 'user', msg.text));

                // è¿½åŠ ä¸€æ¡æç¤º
                appendChatMsg('ai', 'æˆ‘å›æ¥äº†ï¼Œæˆ‘ä»¬ç»§ç»­èŠå§ï½');

                // å­˜å‚¨å½“å‰è®°å½•/è®¡åˆ’çš„ IDï¼Œä¿å­˜æ—¶ç”¨äºæ›´æ–°
                window._continuingRecordId = rec.id;
                window._continuingType = type;
            } catch (e) {
                alert('æ¢å¤å¯¹è¯å¤±è´¥');
            } finally {
                btn.textContent = 'ğŸ’¬ ç»§ç»­èŠå¤©';
                btn.disabled = false;
            }
        }

        function closeDetail() {
            document.getElementById('detail-overlay').classList.remove('show');
            stopEnvelopeParticles();
            document.getElementById('keywords-float').innerHTML = '';
            document.getElementById('chat-log-modal').style.display = 'none';
            const addPhotosBtn = document.getElementById('detail-add-photos');
            addPhotosBtn._rec = null;
            addPhotosBtn._marker = null;
            currentDetailGroup = null;
            currentDetailType = 'record';
        }

        async function removePhotoFromRecord(rec, markerSprite, imagePath) {
            if (!rec || !rec.id || !imagePath) return;
            if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™å¼ ç…§ç‰‡å—ï¼Ÿ')) return;
            try {
                const r = await fetch('/api/records/' + rec.id + '/images', {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ removePath: imagePath })
                });
                const d = await r.json();
                if (!d.success) {
                    alert('åˆ é™¤ç…§ç‰‡å¤±è´¥ï¼š' + (d.error || 'æœªçŸ¥é”™è¯¯'));
                    return;
                }
                const updated = d.record;
                if (markerSprite && markerSprite.userData) markerSprite.userData.record = updated;
                await showDetail(updated, markerSprite || currentDetailGroup, 'record');
            } catch (e) {
                alert('åˆ é™¤ç…§ç‰‡å¤±è´¥');
            }
        }

        async function onAddPhotosToRecord() {
            const btn = document.getElementById('detail-add-photos');
            const rec = btn._rec;
            const marker = btn._marker || currentDetailGroup;
            if (!rec || !rec.id) { alert('è®°å½•ä¿¡æ¯ç¼ºå¤±'); return; }

            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.multiple = true;
            input.onchange = async () => {
                if (!input.files || input.files.length === 0) return;
                try {
                    const fd = new FormData();
                    for (let i = 0; i < input.files.length; i++) fd.append('images', input.files[i]);
                    const uploadRes = await fetch('/api/upload', { method: 'POST', body: fd });
                    const uploadData = await uploadRes.json();
                    if (!uploadData.paths || uploadData.paths.length === 0) {
                        alert('ä¸Šä¼ å¤±è´¥ï¼š' + (uploadData.error || 'æœªè¿”å›å›¾ç‰‡è·¯å¾„'));
                        return;
                    }

                    const patchRes = await fetch('/api/records/' + rec.id + '/images', {
                        method: 'PATCH',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ addPaths: uploadData.paths })
                    });
                    const patchData = await patchRes.json();
                    if (!patchData.success) {
                        alert('æ›´æ–°è®°å½•å¤±è´¥ï¼š' + (patchData.error || 'æœªçŸ¥é”™è¯¯'));
                        return;
                    }

                    const updated = patchData.record;
                    if (marker && marker.userData) marker.userData.record = updated;
                    await showDetail(updated, marker || currentDetailGroup, 'record');
                } catch (e) {
                    alert('ç»§ç»­ä¸Šä¼ å¤±è´¥');
                }
            };
            input.click();
        }

        // ==================== æ’¤å›ä¿¡ç®±/å–æ¶ˆè®¡åˆ’ ====================
        async function deleteCurrentRecord() {
            if(!currentDetailGroup) return;

            if(currentDetailType === 'plan') {
                const plan = currentDetailGroup.userData.plan;
                if(!plan || !plan.id) { alert('æ— æ³•å–æ¶ˆï¼šè®¡åˆ’ä¿¡æ¯ç¼ºå¤±'); return; }
                if(!confirm('ç¡®å®šè¦å–æ¶ˆè¿™ä¸ªæ—…è¡Œè®¡åˆ’å—ï¼Ÿ')) return;
                try {
                    const r = await fetch('/api/plans/' + plan.id, { method:'DELETE' });
                    const d = await r.json();
                    if(d.success) {
                        earthGroup.remove(currentDetailGroup);
                        if(currentDetailGroup.material) currentDetailGroup.material.dispose();
                        const idx = planMarkers.indexOf(currentDetailGroup);
                        if(idx > -1) planMarkers.splice(idx, 1);
                        closeDetail();
                    } else { alert('å–æ¶ˆå¤±è´¥ï¼š' + (d.error || 'æœªçŸ¥é”™è¯¯')); }
                } catch(e) { alert('å–æ¶ˆå¤±è´¥'); }
            } else {
                const rec = currentDetailGroup.userData.record;
                if(!rec || !rec.id) { alert('æ— æ³•æ’¤å›ï¼šè®°å½•ä¿¡æ¯ç¼ºå¤±'); return; }
                if(!confirm('ç¡®å®šè¦æ’¤å›è¿™ä¸ªä¿¡ç®±å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚')) return;
                try {
                    const r = await fetch('/api/records/' + rec.id, { method:'DELETE' });
                    const d = await r.json();
                    if(d.success) {
                        earthGroup.remove(currentDetailGroup);
                        if(currentDetailGroup.material) currentDetailGroup.material.dispose();
                        const idx = recordsMarkers.indexOf(currentDetailGroup);
                        if(idx > -1) recordsMarkers.splice(idx, 1);
                        closeDetail();
                    } else { alert('æ’¤å›å¤±è´¥ï¼š' + (d.error || 'æœªçŸ¥é”™è¯¯')); }
                } catch(e) { alert('æ’¤å›å¤±è´¥'); }
            }
        }

        // ==================== AI èŠå¤©ç³»ç»Ÿ ====================
        let chatSessionId = null;          // å½“å‰ AI å¯¹è¯ä¼šè¯ID
        let chatKeywords = [];             // å½“å‰ç´¯ç§¯çš„å…³é”®è¯
        let isChatActive = false;          // AI èŠå¤©æ˜¯å¦æ´»è·ƒ
        let uploadedImagePaths = [];       // å·²ä¸Šä¼ çš„å›¾ç‰‡è·¯å¾„ï¼ˆç”¨äºAIï¼‰
        let speechRecognition = null;      // Web Speech API å®ä¾‹
        let isRecording = false;           // æ˜¯å¦æ­£åœ¨å½•éŸ³
        let finalTranscript = '';          // ç´¯ç§¯çš„æœ€ç»ˆè¯†åˆ«æ–‡æœ¬ï¼ˆcontinuous æ¨¡å¼ï¼‰
        let sphereAnimId = null;           // ç²’å­çƒåŠ¨ç”»ID
        let sphereParticles = [];          // ç²’å­çƒç²’å­

        // åˆå§‹åŒ– Web Speech APIï¼ˆcontinuous æ¨¡å¼ï¼Œæ‰‹åŠ¨ç»“æŸï¼‰
        function initSpeechRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                console.warn('æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«');
                return;
            }
            speechRecognition = new SpeechRecognition();
            speechRecognition.lang = 'zh-CN';
            speechRecognition.continuous = true;       // æŒç»­ç›‘å¬ï¼Œä¸è‡ªåŠ¨æ–­
            speechRecognition.interimResults = true;

            speechRecognition.onresult = (event) => {
                let interim = '';
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    if (event.results[i].isFinal) {
                        finalTranscript += event.results[i][0].transcript;
                    } else {
                        interim += event.results[i][0].transcript;
                    }
                }
                // ä¿å­˜å½“å‰ interim æ–‡æœ¬ç”¨äºå…œåº•
                window._lastInterim = interim;
                // æ˜¾ç¤ºå®æ—¶æ–‡å­—ï¼šå·²ç¡®è®¤çš„ + ä¸´æ—¶çš„
                const display = finalTranscript + interim;
                document.getElementById('voice-interim').textContent = display.slice(-40);
            };
            speechRecognition.onerror = (e) => {
                console.warn('è¯­éŸ³è¯†åˆ«é”™è¯¯:', e.error);
                if (e.error !== 'no-speech') stopAndSendVoice();
            };
            // continuous æ¨¡å¼ä¸‹æµè§ˆå™¨å¯èƒ½è‡ªåŠ¨ç»“æŸï¼Œéœ€è¦é‡å¯
            speechRecognition.onend = () => {
                if (isRecording) {
                    // è¿˜åœ¨å½•éŸ³æ¨¡å¼ä½†æµè§ˆå™¨è‡ªåŠ¨æ–­äº†ï¼Œé‡æ–°å¯åŠ¨
                    try { speechRecognition.start(); } catch(e) {}
                } else if (window._pendingVoiceSend) {
                    // å½•éŸ³å·²åœæ­¢ï¼Œæµè§ˆå™¨æœ€åçš„ç»“æœå·²è§¦å‘ï¼Œç°åœ¨å‘é€
                    window._pendingVoiceSend = false;
                    const text = (finalTranscript + (window._lastInterim || '')).trim();
                    finalTranscript = '';
                    window._lastInterim = '';
                    if (text) sendChatMessage(text);
                }
            };
        }

        function startRecording() {
            if (!speechRecognition || isRecording) return;
            isRecording = true;
            finalTranscript = ''; // æ¸…ç©ºç´¯ç§¯æ–‡æœ¬
            document.getElementById('btn-voice').classList.add('recording');
            document.getElementById('btn-voice').innerHTML = 'â¹';
            document.getElementById('voice-sphere-wrap').classList.add('show');
            document.getElementById('btn-stop-voice').classList.add('show');
            startSphereAnimation(true);
            try { speechRecognition.start(); } catch(e) {}
            document.getElementById('chat-status').textContent = 'ğŸ”´ æ­£åœ¨å¬... æƒ³å¥½äº†ç‚¹å‡»ç»“æŸ';
        }

        // åœæ­¢å½•éŸ³å¹¶å‘é€ç´¯ç§¯çš„æ–‡å­—
        function stopAndSendVoice() {
            if (!isRecording) return;
            isRecording = false;
            document.getElementById('btn-voice').classList.remove('recording');
            document.getElementById('btn-voice').innerHTML = 'ğŸ¤';
            document.getElementById('voice-sphere-wrap').classList.remove('show');
            document.getElementById('btn-stop-voice').classList.remove('show');
            startSphereAnimation(false);
            document.getElementById('voice-interim').textContent = '';
            document.getElementById('chat-status').textContent = 'å¤„ç†ä¸­...';
            // æ ‡è®°ç­‰å¾…å‘é€ï¼Œè®© onend å›è°ƒå¤„ç†æœ€ç»ˆæ–‡æœ¬
            window._pendingVoiceSend = true;
            try { speechRecognition.stop(); } catch(e) {}
            // å…œåº•ï¼šå¦‚æœ 300ms å onend è¿˜æ²¡è§¦å‘ï¼Œæ‰‹åŠ¨å‘é€
            setTimeout(() => {
                if (window._pendingVoiceSend) {
                    window._pendingVoiceSend = false;
                    const text = (finalTranscript + (window._lastInterim || '')).trim();
                    finalTranscript = '';
                    window._lastInterim = '';
                    document.getElementById('chat-status').textContent = 'å¯¹è¯ä¸­';
                    if (text) sendChatMessage(text);
                }
            }, 500);
        }

        // ä»…åœæ­¢å½•éŸ³ä¸å‘é€ï¼ˆå–æ¶ˆæ—¶ç”¨ï¼‰
        function stopRecordingSilent() {
            if (!isRecording) return;
            isRecording = false;
            finalTranscript = '';
            window._lastInterim = '';
            window._pendingVoiceSend = false;
            document.getElementById('btn-voice').classList.remove('recording');
            document.getElementById('btn-voice').innerHTML = 'ğŸ¤';
            document.getElementById('voice-sphere-wrap').classList.remove('show');
            document.getElementById('btn-stop-voice').classList.remove('show');
            startSphereAnimation(false);
            document.getElementById('voice-interim').textContent = '';
            try { speechRecognition.stop(); } catch(e) {}
            document.getElementById('chat-status').textContent = 'å¯¹è¯ä¸­';
        }

        // å‘é€èŠå¤©æ¶ˆæ¯
        async function sendChatMessage(text) {
            if (!text.trim() || !chatSessionId) return;
            // ç”¨æˆ·æ¶ˆæ¯ä¸Šå±
            appendChatMsg('user', text);
            document.getElementById('chat-text-input').value = '';
            // æ˜¾ç¤ºæ­£åœ¨è¾“å…¥...
            const typingEl = appendTyping();
            try {
                const r = await fetch('/api/chat/message', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sessionId: chatSessionId, message: text })
                });
                const d = await r.json();
                removeTyping(typingEl);
                if (d.success) {
                    appendChatMsgTyping(d.reply);
                    chatKeywords = d.keywords || [];
                } else {
                    const errMsg = d.error && d.error.includes('RESOURCE_EXHAUSTED')
                        ? 'è¯·æ±‚å¤ªé¢‘ç¹äº†ï¼Œç­‰å‡ ç§’å†è¯•è¯•ï½'
                        : (d.error && d.error.includes('è¿‡æœŸ') ? 'å¯¹è¯è¶…æ—¶äº†ï¼Œè¯·é‡æ–°ä¸Šä¼ å›¾ç‰‡å¼€å§‹' : 'æŠ±æ­‰ï¼ŒAIæš‚æ—¶å¿™ç¢Œï¼Œç¨åå†è¯•ï½');
                    appendChatMsg('ai', errMsg);
                }
            } catch (e) {
                removeTyping(typingEl);
                appendChatMsg('ai', 'ç½‘ç»œé”™è¯¯ï¼Œè¯·ç¨åå†è¯•');
            }
        }

        // å¼€å§‹ AI å¯¹è¯ï¼ˆä¸Šä¼ å›¾ç‰‡åè‡ªåŠ¨è§¦å‘ï¼‰
        async function startAIChat(imagePaths, location) {
            const chatSection = document.getElementById('chat-section');
            const chatMsgs = document.getElementById('chat-messages');
            chatSection.style.display = '';
            chatMsgs.innerHTML = '';
            chatKeywords = [];
            chatSessionId = null;
            document.getElementById('chat-title').textContent = 'ğŸ¦Œ æ‹¾å…‰é¹¿ Â· å›å¿†æ”¶é›†å®¶';
            document.getElementById('chat-status').textContent = 'æ‹¾å…‰é¹¿æ€è€ƒä¸­...';

            const typingEl = appendTyping();
            try {
                const r = await fetch('/api/chat/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ imagePaths: imagePaths || [], location: location || '' })
                });
                const d = await r.json();
                removeTyping(typingEl);
                if (d.success) {
                    chatSessionId = d.sessionId;
                    chatKeywords = d.keywords || [];
                    isChatActive = true;
                    appendChatMsgTyping(d.reply);
                    document.getElementById('chat-status').textContent = 'å¯¹è¯ä¸­';
                } else {
                    appendChatMsg('ai', 'AI è¿æ¥å¤±è´¥ï¼š' + (d.error || ''));
                    document.getElementById('chat-status').textContent = 'è¿æ¥å¤±è´¥';
                }
            } catch (e) {
                removeTyping(typingEl);
                appendChatMsg('ai', 'æ— æ³•è¿æ¥åˆ° AI æœåŠ¡ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ');
                document.getElementById('chat-status').textContent = 'è¿æ¥å¤±è´¥';
            }
        }

        // å¼€å§‹æ—…è¡Œè®¡åˆ’ AI å¯¹è¯ï¼ˆé€‰ä½åè‡ªåŠ¨è§¦å‘ï¼‰
        async function startPlanAIChat(location) {
            const chatSection = document.getElementById('chat-section');
            const chatMsgs = document.getElementById('chat-messages');
            chatSection.style.display = '';
            chatMsgs.innerHTML = '';
            chatKeywords = [];
            chatSessionId = null;
            document.getElementById('chat-title').textContent = 'ğŸ± æ¼«æ¸¸å–µ Â· æ—…è¡Œè§„åˆ’å¸ˆ';
            document.getElementById('chat-status').textContent = 'æ¼«æ¸¸å–µæ€è€ƒä¸­...';

            const typingEl = appendTyping();
            try {
                const r = await fetch('/api/chat/start-plan', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ location: location || '' })
                });
                const d = await r.json();
                removeTyping(typingEl);
                if (d.success) {
                    chatSessionId = d.sessionId;
                    chatKeywords = d.keywords || [];
                    isChatActive = true;
                    appendChatMsgTyping(d.reply);
                    document.getElementById('chat-status').textContent = 'å¯¹è¯ä¸­';
                } else {
                    appendChatMsg('ai', 'æ¼«æ¸¸å–µè¿æ¥å¤±è´¥ï¼š' + (d.error || ''));
                    document.getElementById('chat-status').textContent = 'è¿æ¥å¤±è´¥';
                }
            } catch (e) {
                removeTyping(typingEl);
                appendChatMsg('ai', 'æ— æ³•è¿æ¥åˆ°æ¼«æ¸¸å–µï¼Œè¯·æ£€æŸ¥ç½‘ç»œ');
                document.getElementById('chat-status').textContent = 'è¿æ¥å¤±è´¥';
            }
        }

        // å¾€èŠå¤©çª—å£è¿½åŠ æ¶ˆæ¯
        // æ¸…ç†AIå›å¤ä¸­çš„markdownæ˜Ÿå·ï¼Œä¿ç•™æ¢è¡Œ
        function cleanAIText(text) {
            let s = (text || '').replace(/\*\*/g, '').replace(/\*/g, '');
            // ç§»é™¤æ³„éœ²çš„ ,"keywords":[...] ç­‰ JSON ç‰‡æ®µ
            s = s.replace(/["']?\s*,\s*["']?keywords["']?\s*:\s*\[[\s\S]*\]\s*$/i, '').trim();
            return s;
        }

        function appendChatMsg(role, text) {
            const msgs = document.getElementById('chat-messages');
            const div = document.createElement('div');
            div.className = 'chat-msg ' + role;
            const avatar = document.createElement('div');
            avatar.className = 'chat-avatar';
            avatar.textContent = role === 'ai' ? 'âœ¨' : 'ğŸ§‘';
            const bubble = document.createElement('div');
            bubble.className = 'chat-bubble';
            bubble.textContent = role === 'ai' ? cleanAIText(text) : text;
            if (role === 'ai') { div.appendChild(avatar); div.appendChild(bubble); }
            else { div.appendChild(bubble); div.appendChild(avatar); }
            msgs.appendChild(div);
            msgs.scrollTop = msgs.scrollHeight;
        }
        // AI æ‰“å­—å¼å›å¤ï¼ˆé€å­—æ˜¾ç¤º + å…‰æ ‡é—ªçƒï¼‰
        function appendChatMsgTyping(text, onComplete) {
            const msgs = document.getElementById('chat-messages');
            const div = document.createElement('div');
            div.className = 'chat-msg ai';
            const avatar = document.createElement('div');
            avatar.className = 'chat-avatar';
            avatar.textContent = 'âœ¨';
            const bubble = document.createElement('div');
            bubble.className = 'chat-bubble typing-active';
            const textSpan = document.createElement('span');
            const cursorSpan = document.createElement('span');
            cursorSpan.className = 'typing-cursor';
            cursorSpan.setAttribute('aria-hidden', 'true');
            div.appendChild(avatar);
            bubble.appendChild(textSpan);
            bubble.appendChild(cursorSpan);
            div.appendChild(bubble);
            msgs.appendChild(div);
            const full = cleanAIText(text || '');
            let i = 0;
            const step = 2;
            const interval = 35; // çº¦ 0.8x é€Ÿç‡
            function tick() {
                if (i >= full.length) {
                    cursorSpan.remove();
                    bubble.classList.remove('typing-active');
                    if (onComplete) onComplete();
                    return;
                }
                i = Math.min(i + step, full.length);
                textSpan.textContent = full.slice(0, i);
                msgs.scrollTop = msgs.scrollHeight;
                setTimeout(tick, interval);
            }
            tick();
        }
        function appendTyping() {
            const msgs = document.getElementById('chat-messages');
            const div = document.createElement('div');
            div.className = 'chat-msg ai';
            div.innerHTML = '<div class="chat-avatar">âœ¨</div><div class="chat-bubble"><div class="chat-typing"><span></span><span></span><span></span></div></div>';
            msgs.appendChild(div);
            msgs.scrollTop = msgs.scrollHeight;
            return div;
        }
        function removeTyping(el) { if (el && el.parentNode) el.parentNode.removeChild(el); }

        // ==================== ç´«è‰²ç²’å­çƒåŠ¨ç”» ====================
        function startSphereAnimation(active) {
            const canvas = document.getElementById('voice-sphere-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const w = canvas.width, h = canvas.height;
            const cx = w / 2, cy = h / 2, maxR = 60;

            if (!active) {
                if (sphereAnimId) { cancelAnimationFrame(sphereAnimId); sphereAnimId = null; }
                ctx.clearRect(0, 0, w, h);
                sphereParticles = [];
                return;
            }

            // åˆå§‹åŒ–ç²’å­
            if (sphereParticles.length === 0) {
                const SPHERE_COLORS = [
                    [167,139,179], [128,96,176], [192,160,224], [96,64,160],
                    [180,150,220], [140,100,200], [200,180,240], [160,120,210]
                ];
                // å¤–å±‚æ—‹è½¬ç²’å­
                for (let i = 0; i < 1500; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = maxR * (0.85 + Math.random() * 0.25);
                    sphereParticles.push({
                        theta, phi, r,
                        speed: (0.3 + Math.random() * 0.7) * (Math.random() > 0.5 ? 1 : -1),
                        size: 0.5 + Math.random() * 1.2,
                        color: SPHERE_COLORS[Math.floor(Math.random() * SPHERE_COLORS.length)],
                        alpha: 0.3 + Math.random() * 0.6,
                        type: 'orbit'
                    });
                }
                // ä¸­å¿ƒæµ®ç°ç²’å­
                for (let i = 0; i < 500; i++) {
                    sphereParticles.push({
                        x: (Math.random() - 0.5) * maxR * 0.8,
                        y: (Math.random() - 0.5) * maxR * 0.8,
                        vx: (Math.random() - 0.5) * 0.5,
                        vy: (Math.random() - 0.5) * 0.5,
                        size: 0.8 + Math.random() * 1.5,
                        color: SPHERE_COLORS[Math.floor(Math.random() * SPHERE_COLORS.length)],
                        alpha: Math.random() * 0.6,
                        life: Math.random() * 3,
                        maxLife: 1 + Math.random() * 3,
                        type: 'center'
                    });
                }
            }

            const startTime = performance.now();
            function animSphere() {
                const t = (performance.now() - startTime) / 1000;
                ctx.clearRect(0, 0, w, h);

                // ä¸­å¿ƒå…‰æ™•
                const glowR = maxR * 0.6;
                const glow = ctx.createRadialGradient(cx, cy, 0, cx, cy, glowR);
                glow.addColorStop(0, `rgba(160,120,220,${0.15 + 0.05 * Math.sin(t * 2)})`);
                glow.addColorStop(0.5, 'rgba(120,80,180,0.05)');
                glow.addColorStop(1, 'rgba(100,60,160,0)');
                ctx.fillStyle = glow;
                ctx.beginPath(); ctx.arc(cx, cy, glowR, 0, Math.PI * 2); ctx.fill();

                for (const p of sphereParticles) {
                    if (p.type === 'orbit') {
                        // å¤–å±‚æ—‹è½¬
                        p.theta += p.speed * 0.015;
                        const x3d = p.r * Math.sin(p.phi) * Math.cos(p.theta);
                        const y3d = p.r * Math.cos(p.phi);
                        const z3d = p.r * Math.sin(p.phi) * Math.sin(p.theta);
                        const depth = (z3d + p.r) / (2 * p.r); // 0~1
                        const px = cx + x3d;
                        const py = cy + y3d;
                        const a = p.alpha * (0.2 + 0.8 * depth);
                        if (a < 0.02) continue;
                        const [r, g, b] = p.color;
                        ctx.fillStyle = `rgba(${r},${g},${b},${a})`;
                        ctx.beginPath();
                        ctx.arc(px, py, p.size * (0.5 + 0.5 * depth), 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // ä¸­å¿ƒæµ®ç°
                        p.life -= 0.016;
                        p.x += p.vx; p.y += p.vy;
                        if (p.life <= 0) {
                            p.x = (Math.random() - 0.5) * maxR * 0.6;
                            p.y = (Math.random() - 0.5) * maxR * 0.6;
                            p.vx = (Math.random() - 0.5) * 0.5;
                            p.vy = (Math.random() - 0.5) * 0.5;
                            p.life = p.maxLife;
                            p.alpha = Math.random() * 0.6;
                        }
                        const fadeIn = Math.min(1, (p.maxLife - p.life) / 0.5);
                        const fadeOut = Math.min(1, p.life / 0.5);
                        const a = p.alpha * fadeIn * fadeOut;
                        if (a < 0.02) continue;
                        const [r, g, b] = p.color;
                        ctx.fillStyle = `rgba(${r},${g},${b},${a})`;
                        ctx.beginPath();
                        ctx.arc(cx + p.x, cy + p.y, p.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                sphereAnimId = requestAnimationFrame(animSphere);
            }
            if (sphereAnimId) cancelAnimationFrame(sphereAnimId);
            animSphere();
        }

        // ==================== è¡¨å• ====================
        function showForm(lat, lon, locationLabel) {
            const isPlan = formMode === 'plan';
            // æ ‡é¢˜
            document.querySelector('#form-box h3').textContent = isPlan ? 'æ·»åŠ æ—…è¡Œè®¡åˆ’' : 'æ·»åŠ æ—…è¡Œè®°å½•';
            // å›¾ç‰‡åŒºåŸŸæ˜¾éš
            document.getElementById('image-section').style.display = isPlan ? 'none' : '';
            // AI èŠå¤©åŒºåŸŸï¼šä¸¤ç§æ¨¡å¼éƒ½æ”¯æŒï¼Œåˆå§‹éšè—ï¼ˆè®°å½•æ¨¡å¼ä¸Šä¼ å›¾ç‰‡åæ˜¾ç¤ºï¼Œè®¡åˆ’æ¨¡å¼é€‰ä½åæ˜¾ç¤ºï¼‰
            document.getElementById('chat-section').style.display = 'none';
            document.getElementById('chat-messages').innerHTML = '';
            chatSessionId = null; isChatActive = false; chatKeywords = []; uploadedImagePaths = [];
            // åæ ‡æç¤º
            let coordText = isPlan
                ? 'å°šæœªå®šä½ â€” ç‚¹å‡»ä¸‹æ–¹ã€Œåœ°å›¾å®šä½ã€é€‰æ‹©ç›®çš„åœ°'
                : 'å°šæœªå®šä½ â€” ä¸Šä¼ å«GPSçš„ç…§ç‰‡æˆ–ç‚¹å‡»ä¸‹æ–¹ã€Œåœ°å›¾å®šä½ã€';
            if(lat!==null) {
                coordText = `ç»çº¬åº¦ï¼š${lat.toFixed(4)}Â°, ${lon.toFixed(4)}Â°`;
                if(locationLabel) coordText += ` Â· ${locationLabel}`;
            }
            document.getElementById('coord-display').textContent = coordText;
            document.getElementById('desc-input').value='';
            document.getElementById('desc-input').placeholder = isPlan ? 'å†™ä¸‹ä½ çš„æ—…è¡Œè®¡åˆ’ï¼ˆå¯é€‰ï¼ŒAIä¼šå¸®ä½ æ€»ç»“ï¼‰...' : 'å†™ä¸‹ä½ çš„æ—…è¡Œæ„Ÿå—ï¼ˆå¯é€‰ï¼ŒAIä¼šå¸®ä½ è¡¥å……ï¼‰...';
            document.getElementById('image-input').value='';
            document.getElementById('image-count').textContent='';
            document.getElementById('gps-hint').textContent='';
            document.getElementById('city-search-input').value = '';
            // æ—¥æœŸé€‰æ‹©å™¨ï¼šæ—…è¡Œè®°å½•æ˜¾ç¤ºï¼Œè®¡åˆ’éšè—
            document.getElementById('date-section').style.display = isPlan ? 'none' : '';
            document.getElementById('photo-date').value = '';
            document.getElementById('form-overlay').classList.add('show');
        }
        function hideForm() {
            document.getElementById('form-overlay').classList.remove('show');
            pendingRecord=null;
            // åœæ­¢è¯­éŸ³å’Œç²’å­çƒ
            if (isRecording) stopRecordingSilent();
            startSphereAnimation(false);
            chatSessionId = null; isChatActive = false;
            window._continuingRecordId = null;
            window._continuingType = null;
            // å¦‚æœæ­£åœ¨é€‰ä½æ¨¡å¼ä¹Ÿä¸€å¹¶é€€å‡º
            if(awaitingLocationClick) {
                awaitingLocationClick=false;
                pickedLocation=null;
                document.getElementById('pick-hint').classList.remove('show');
                hideLocConfirm();
            }
        }

        async function onSaveRecord() {
            // é˜²æ­¢é‡å¤ç‚¹å‡»ï¼šç«‹å³ç¦ç”¨ä¿å­˜æŒ‰é’®å¹¶æ˜¾ç¤ºåŠ è½½çŠ¶æ€
            const saveBtn = document.getElementById('btn-save');
            if (saveBtn.disabled) return; // å·²åœ¨ä¿å­˜ä¸­ï¼Œç›´æ¥å¿½ç•¥
            saveBtn.disabled = true;
            saveBtn.textContent = 'ä¿å­˜ä¸­...';
            saveBtn.style.opacity = '0.6';
            saveBtn.style.cursor = 'not-allowed';
            const restoreBtn = () => { saveBtn.disabled = false; saveBtn.textContent = 'ä¿å­˜'; saveBtn.style.opacity = '1'; saveBtn.style.cursor = 'pointer'; };
            const desc=document.getElementById('desc-input').value.trim();
            // ç»§ç»­èŠå¤©æ¨¡å¼ä¸éœ€è¦æ£€æŸ¥ pendingRecord
            if(!pendingRecord && !window._continuingRecordId){alert('è¯·å…ˆé€‰æ‹©ä½ç½®ï¼ˆä½¿ç”¨åœ°å›¾å®šä½ï¼‰');restoreBtn();return;}

            // ç»§ç»­èŠå¤©æ¨¡å¼ï¼šæ›´æ–°å·²æœ‰è®°å½•/è®¡åˆ’çš„èŠå¤©æ•°æ®
            if (window._continuingRecordId) {
                const id = window._continuingRecordId;
                const type = window._continuingType || 'record';
                const endpoint = type === 'plan' ? `/api/plans/${id}/chat` : `/api/records/${id}/chat`;
                if (!chatSessionId) {
                    alert('å¯¹è¯ä¼šè¯å·²æ–­å¼€ï¼Œè¯·é‡æ–°æ‰“å¼€è®°å½•ç»§ç»­èŠå¤©');
                    window._continuingRecordId = null;
                    window._continuingType = null;
                    restoreBtn(); return;
                }
                try {
                    const r = await fetch(endpoint, {
                        method: 'PATCH',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ chatSessionId })
                    });
                    const d = await r.json();
                    if (d.success) {
                        const markers = type === 'plan' ? planMarkers : recordsMarkers;
                        const marker = markers.find(m => {
                            const data = type === 'plan' ? m.userData?.plan : m.userData?.record;
                            return data && data.id === id;
                        });
                        if (marker) {
                            const updated = type === 'plan' ? d.plan : d.record;
                            if (type === 'plan') marker.userData.plan = updated;
                            else marker.userData.record = updated;
                        }
                        window._continuingRecordId = null;
                        window._continuingType = null;
                        hideForm();
                        alert('å¯¹è¯å·²æ›´æ–°ä¿å­˜ï¼');
                    } else { alert('ä¿å­˜å¤±è´¥ï¼š' + (d.error || '')); restoreBtn(); }
                } catch(e) { console.error('ç»§ç»­èŠå¤©ä¿å­˜å¤±è´¥:', e); alert('ä¿å­˜å¤±è´¥ï¼šç½‘ç»œé”™è¯¯'); restoreBtn(); }
                return;
            }

            if(formMode === 'plan') {
                // æœ‰ AI å¯¹è¯æ—¶å¯ä»¥ä¸å¡«æè¿°ï¼ˆåç«¯ä¼šç”Ÿæˆ AI æ€»ç»“ï¼‰
                const planDesc = desc || (isChatActive && chatSessionId ? 'ï¼ˆAI å°†è‡ªåŠ¨ç”Ÿæˆè®¡åˆ’æ‘˜è¦ï¼‰' : '');
                if(!planDesc){alert('è¯·è¾“å…¥è®¡åˆ’æè¿°æˆ–å…ˆä¸AIèŠå¤©');restoreBtn();return;}
                // ä¿å­˜æ—…è¡Œè®¡åˆ’ï¼ˆå«AIèŠå¤©æ•°æ®ï¼‰
                const plan={
                    lat:pendingRecord.lat, lon:pendingRecord.lon,
                    description:planDesc,
                    chatSessionId: chatSessionId || undefined
                };
                try{
                    const r=await fetch('/api/plans',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(plan)});
                    const d=await r.json();
                    if(d.success){createPlanSprite(plan.lat,plan.lon,d.plan);hideForm();alert('âœ“ è®¡åˆ’ä¿å­˜æˆåŠŸï¼');}
                    else {alert('ä¿å­˜å¤±è´¥ï¼š'+(d.error||'æœªçŸ¥'));restoreBtn();}
                }catch(e){alert('ä¿å­˜å¤±è´¥');restoreBtn();}
            } else {
                // ä¿å­˜æ—…è¡Œè®°å½•ï¼ˆå«å›¾ç‰‡ + AI èŠå¤©æ•°æ®ï¼‰
                // å…ˆä¸Šä¼ å›¾ç‰‡ï¼ˆå¦‚æœè¿˜æ²¡ä¸Šä¼ è¿‡ï¼‰
                const imageInput=document.getElementById('image-input');
                let imagePaths = uploadedImagePaths.length > 0 ? uploadedImagePaths : [];
                if(imagePaths.length === 0 && imageInput.files && imageInput.files.length > 0){
                    const fd=new FormData();
                    for(let i=0; i<imageInput.files.length; i++) fd.append('images', imageInput.files[i]);
                    try{
                        const r=await fetch('/api/upload',{method:'POST',body:fd});
                        const d=await r.json();
                        if(d.paths) imagePaths=d.paths;
                        else if(d.error) { alert('å›¾ç‰‡ä¸Šä¼ å¤±è´¥ï¼š' + d.error); restoreBtn(); return; }
                    } catch(e){alert('å›¾ç‰‡ä¸Šä¼ å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶å¤§å°å’Œæ ¼å¼');restoreBtn();return;}
                }
                // æœ‰ AI å¯¹è¯æ—¶å¯ä»¥ä¸å¡«æè¿°ï¼ˆåç«¯ä¼šç”Ÿæˆ AI æ€»ç»“ï¼‰ï¼›æ—  AI å¯¹è¯åˆ™å¿…é¡»å¡«æè¿°
                const descText = desc || (isChatActive && chatSessionId ? 'ï¼ˆAI å°†è‡ªåŠ¨ç”Ÿæˆæ—¥è®°ï¼‰' : '');
                if(!descText){alert('è¯·è¾“å…¥æ–‡å­—æè¿°æˆ–å…ˆä¸AIèŠå¤©');restoreBtn();return;}
                const photoDate = document.getElementById('photo-date').value || undefined;
                const record={
                    lat:pendingRecord.lat, lon:pendingRecord.lon,
                    description:descText,
                    imagePaths: imagePaths.length>0 ? imagePaths : undefined,
                    chatSessionId: chatSessionId || undefined, // åç«¯ä¼šä»ä¸­æå– keywords å’Œ chatLog
                    photoDate // æ‹æ‘„æ—¥æœŸï¼ˆYYYY-MM-DDï¼‰ï¼Œç”¨äºè·å–å†å²å¤©æ°”
                };
                try{
                    const r=await fetch('/api/records',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(record)});
                    const d=await r.json();
                    if(d.success){createMailboxSprite(record.lat,record.lon,d.record);hideForm();alert('âœ“ æ—…è¡Œè®°å½•ä¿å­˜æˆåŠŸï¼');}
                    else {alert('ä¿å­˜å¤±è´¥ï¼š'+(d.error||'æœªçŸ¥'));restoreBtn();}
                }catch(e){alert('ä¿å­˜å¤±è´¥');restoreBtn();}
            }
        }

        async function loadRecords() {
            try{
                const r=await fetch('/api/records');const records=await r.json();
                records.forEach(rec=>createMailboxSprite(rec.lat,rec.lon,rec));
            }catch(e){console.warn('åŠ è½½è®°å½•å¤±è´¥',e);}
        }

        async function loadPlans() {
            try{
                const r=await fetch('/api/plans');const plans=await r.json();
                plans.forEach(p=>createPlanSprite(p.lat,p.lon,p));
            }catch(e){console.warn('åŠ è½½è®¡åˆ’å¤±è´¥',e);}
        }

        // ==================== resize ====================
        function onWindowResize() {
            camera.aspect=innerWidth/innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth,innerHeight);
            borderLineMaterials.forEach(m=>{m.resolution.set(innerWidth,innerHeight);});
        }

        // ==================== æ¸²æŸ“å¾ªç¯ ====================
        function animate() {
            requestAnimationFrame(animate);
            if(earthGroup){
                earthGroup.rotation.y+=(targetRotationY-earthGroup.rotation.y)*.05;
                earthGroup.rotation.x+=(targetRotationX-earthGroup.rotation.x)*.05;
                if(!isDragging) targetRotationY+=.0002;
            }
            const zoomed = camera.position.z < ZOOM_THRESHOLD;
            continentLabels.forEach(s=>{s.visible=!zoomed;});
            countryLabels.forEach(s=>{s.visible=zoomed;});

            // åŠ¨æ€è½®å»“çº¿ç²—ç»†
            if(borderLineMaterials.length > 0) {
                const t = Math.max(0, Math.min(1, (camera.position.z - 350) / (900 - 350)));
                borderLineMaterials[0].linewidth = 0.5 + 0.5 * t;
            }
            // é«˜äº®å›½å¢ƒçº¿çš„åˆ†è¾¨ç‡éœ€éšçª—å£æ›´æ–°
            if(highlightBorderGroup) highlightBorderGroup.traverse(o=>{ if(o.material&&o.material.resolution) o.material.resolution.set(innerWidth,innerHeight); });

            // æ”¾å¤§æ—¶ï¼šç²’å­å˜æš—50% + æ˜¾ç¤ºé¢å¤–ç²’å­ï¼ˆ1.5å€ï¼‰
            if(particleMaterial) {
                const targetB = zoomed ? 0.3 : 1.0;
                const targetShow = zoomed ? 1.0 : 0.0;
                particleMaterial.uniforms.brightness.value += (targetB - particleMaterial.uniforms.brightness.value) * 0.05;
                particleMaterial.uniforms.showExtra.value += (targetShow - particleMaterial.uniforms.showExtra.value) * 0.05;
            }

            drawLatAxis();
            renderer.render(scene,camera);
        }
    </script>
</body>
</html>
